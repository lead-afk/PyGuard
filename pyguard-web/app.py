from fastapi import FastAPI, Request, Form, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse, Response, JSONResponse, StreamingResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
import httpx
import logging
import os

API_BASE = os.environ.get("PYGUARD_API_BASE", "http://127.0.0.1:6655")

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("pyguard-web")

DEBUG = os.environ.get("PYGUARD_WEB_DEBUG", "1") in ("1", "true", "True")

app = FastAPI(title="PyGuard Web", debug=DEBUG)
app.mount(
    "/static",
    StaticFiles(directory=str(os.path.join(os.path.dirname(__file__), "static"))),
    name="static",
)
templates = Jinja2Templates(
    directory=str(os.path.join(os.path.dirname(__file__), "templates"))
)
# Always reload Jinja templates in development
try:
    templates.env.auto_reload = True
    # Disable template bytecode cache in dev to force recompile
    templates.env.cache = {}
except Exception:
    pass

# In-memory session (simple placeholder) keyed by cookie token
_sessions: dict[str, str] = {}

from starlette.middleware.sessions import SessionMiddleware

app.add_middleware(
    SessionMiddleware,
    secret_key=os.environ.get("PYGUARD_WEB_SECRET", "dev-secret-change"),
)


@app.get("/favicon.ico")
async def favicon():
    # 1x1 transparent PNG bytes
    png = (
        b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x10\x00\x00\x00\x10\x08\x06\x00\x00\x00\x1f\xf3\xffa"
        b"\x00\x00\x00\x04sBIT\x08\x08\x08\x08|\x08d\x88\x00\x00\x00\x09pHYs\x00\x00\x0b\x13\x00\x00\x0b\x13\x01"
        b"\x00\x9a\x9c\x18\x00\x00\x00\x07tIME\x07\xe9\t\x07\r\x0c\x18\xc0y\x99\x9f\x00\x00\x00\x19tEXtComment\x00Generated by PyGuard Web\x9c\xce\x1d\x00\x00\x00>IDAT8\x8dcdc``\xf8\xcf\x00\x06\x06\x06\x06\x06\x86\x0d\x8c\x0c\x8c\x8c\x0cL@\x18\x00\x00\t\x19\x01\x04\xb2Y\xe7\xf3\x00\x00\x00\x00IEND\xaeB`\x82"
    )
    return Response(content=png, media_type="image/png")


@app.get("/", response_class=HTMLResponse)
async def root(request: Request):
    token = request.session.get("access_token")
    if token:
        return RedirectResponse("/dashboard")
    return templates.TemplateResponse("login.html", {"request": request})


@app.post("/login", response_class=HTMLResponse)
async def do_login(request: Request, password: str = Form(...)):
    async with httpx.AsyncClient(timeout=5.0) as client:
        try:
            resp = await client.post(f"{API_BASE}/login", json={"password": password})
        except httpx.RequestError:
            raise HTTPException(status_code=502, detail="API unreachable")
    if resp.status_code != 200:
        log.info("Login failed: status=%s", resp.status_code)
        return templates.TemplateResponse(
            "login.html", {"request": request, "error": "Invalid password"}
        )
    data = resp.json()
    if "access_token" not in data:
        log.error("API /login response missing access_token: %s", data)
        return templates.TemplateResponse(
            "login.html", {"request": request, "error": "Malformed API response"}
        )
    request.session["access_token"] = data["access_token"]
    request.session["refresh_token"] = data.get("refresh_token")
    log.info("Login success, redirecting to /dashboard")
    return RedirectResponse("/dashboard", status_code=303)


@app.get("/logout")
async def logout(request: Request):
    request.session.clear()
    return RedirectResponse("/", status_code=303)


@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request):
    token = request.session.get("access_token")
    if not token:
        return RedirectResponse("/", status_code=303)
    # Initial lightweight interface list (JS will refresh anyway)
    headers = {"Authorization": f"Bearer {token}"}
    interfaces = []
    async with httpx.AsyncClient(timeout=5.0) as client:
        try:
            r = await client.get(f"{API_BASE}/interfaces", headers=headers)
            if r.status_code == 200:
                interfaces = r.json().get("interfaces", [])
            elif r.status_code == 401:
                request.session.clear()
                return RedirectResponse("/", status_code=303)
        except httpx.RequestError:
            pass
    log.info("Render dashboard with %d interfaces", len(interfaces))
    # Pass token to template (embedded in meta tag). For production, consider backend proxy instead.
    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "interfaces": interfaces,
        },
    )

# --------------------
# Backend proxy layer
# --------------------

def _auth_headers(request: Request) -> dict[str, str]:
    token = request.session.get("access_token")
    if not token:
        raise HTTPException(status_code=401, detail="Not authenticated")
    return {"Authorization": f"Bearer {token}"}

async def _proxy(method: str, path: str, request: Request):
    # Disallow direct login/refresh via proxy (handled locally)
    if path.strip("/") in ("login", "refresh"):
        raise HTTPException(status_code=400, detail="Use web login")
    url = f"{API_BASE}/{path}".rstrip("/")
    headers = _auth_headers(request)
    # Forward JSON/body/query params
    data = await request.body()
    params = dict(request.query_params)
    async with httpx.AsyncClient(timeout=15.0) as client:
        try:
            resp = await client.request(
                method,
                url,
                headers=headers,
                params=params or None,
                content=data if data else None,
            )
        except httpx.RequestError as e:
            raise HTTPException(status_code=502, detail=f"Upstream error: {e}")
    # Pass through JSON / text / binary
    content_type = resp.headers.get("content-type", "application/octet-stream")
    if content_type.startswith("application/json"):
        return JSONResponse(status_code=resp.status_code, content=resp.json())
    return Response(content=resp.content, media_type=content_type, status_code=resp.status_code)

@app.api_route("/proxy/{full_path:path}", methods=["GET", "POST", "PUT", "PATCH", "DELETE"])
async def proxy_any(full_path: str, request: Request):
    return await _proxy(request.method, full_path, request)
