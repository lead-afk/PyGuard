<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>PyGuard Dashboard</title>
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      body,
      html {
        height: 100%;
        background-image: url("/static/img/background.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        overflow: hidden;
      }
      .top-bar {
        max-width: 1750px;
        margin: 14px auto 0;
        border-radius: 18px;
        padding: 10px 30px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: 1px solid #1f2c38;
        box-shadow: 0 4px 16px -6px rgba(0, 0, 0, 0.55);
      }
      .top-bar .logo-title img.logo-small {
        width: 42px;
      }
      .top-bar .logo-title h1 {
        font-size: 22px;
      }
      .island-wrapper {
        max-width: 1750px;
        margin: 22px auto 40px;
        padding: 0 18px;
        display: flex;
        justify-content: center;
        min-height: 300px;
      }
      .island {
        position: relative;
        background: #0d141a;
        border: 1px solid #1e2a36;
        border-radius: 26px;
        padding: 34px 46px 46px;
        min-height: 200px;
        max-width: 600px;
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 28px;
        box-shadow: 0 10px 40px -12px rgba(0, 0, 0, 0.65),
          0 0 0 1px #182430 inset;
        transition: all 0.4s ease-out;
        overflow: hidden;
        max-height: 720px;
      }
      #island {
        /* opacity: 0.97; */
        background-color: #182430e3;
        /* backdrop-filter: blur(6px); */
      }
      .island.expanded {
        padding: 28px 30px 40px;
        flex-direction: row;
        align-items: flex-start;
        gap: 34px;
        /* Compact by default (no peer selected) */
        max-width: 1160px;
        min-height: 420px;
        width: 100%;
      }
      /* When a peer is actually open, allow full expansion */
      .island.expanded.peer-open {
        max-width: 1750px;
        min-height: 560px;
      }
      .interfaces-panel {
        width: 100%;
        transition: all 0.4s ease-out;
        position: relative;
        max-height: 660px;
        display: flex;
        flex-direction: column;
      }
      .island.expanded .interfaces-panel {
        width: 270px;
        padding: 26px 20px 32px;
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 26px;
        box-shadow: 0 0 0 1px #16222c inset, 0 8px 28px -14px #000;
        display: flex;
        flex-direction: column;
      }
      .interfaces-panel h3 {
        margin: 0 0 14px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      /* Add spacing under the Add Interface button */
      #btnOpenAddInterface {
        margin-bottom: 14px;
      }
      .iface-list {
        flex: 1;
        overflow-y: auto;
        padding-right: 4px;
        max-height: 800px;
        min-height: 120px;
      }
      .iface-item {
        cursor: pointer;
        padding: 10px 14px;
        font-size: 14px;
        color: #cfd8dc;
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: space-between;
        margin: 6px 4px 0;
        background: #15202a;
        border: 1px solid #1f2c38;
        border-radius: 10px;
        transition: background 0.25s, border-color 0.25s, transform 0.25s;
      }
      .iface-item:hover {
        background: #1d2c38;
      }
      .iface-item.active {
        background: #27455e;
        color: #fff;
        border-color: #335d7a;
      }
      /* removed status-dot in favor of pills */
      .details-region {
        display: none;
        flex-direction: column;
        gap: 22px;
        position: relative;
        flex: 1;
        min-width: 0;
      }
      .island.expanded .details-region {
        display: flex;
        margin-left: 0;
      }
      .details-region.peer-open .peer-detail-panel {
        /* reveal smoothly */
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
        flex-basis: 500px;
        max-width: 500px;
        width: 500px;
      }
      .iface-meta-card {
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 16px;
        padding: 18px 22px 20px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 28px;
        position: relative;
        overflow: hidden;
        min-height: 100px;
        transition: all 0.4s ease-out;
      }
      /* remove gray overlay for consistency with other sections */
      .iface-meta-card:before {
        display: none;
      }
      /* add a little more space under the server name */
      .iface-meta-left h2 {
        margin: 0 0 14px;
        font-size: 22px;
        letter-spacing: 0.5px;
      }
      .iface-stats {
        display: flex;
        gap: 18px;
        flex-wrap: wrap;
        font-size: 13px;
        color: #a7bac6;
        margin-top: 20px;
        width: 780px;
      }
      .iface-stat {
        background: #182733;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid #243744;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 110px;
      }
      .iface-stat span.label {
        text-transform: uppercase;
        font-size: 10px;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      .iface-actions {
        display: flex;
        gap: 10px;
      }
      .iface-actions button {
        padding: 10px 14px;
        font-size: 13px;
        border-radius: 10px;
      }
      .peers-section {
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 22px;
        padding: 20px 24px 26px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: relative;
        transition: all 0.4s ease-out;
        min-height: 0; /* allow internal scroll containers */
      }
      .peers-layout {
        display: flex;
        gap: 26px;
        align-items: flex-start;
        min-height: 0; /* enable child scroll areas */
      }
      .peers-left {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 0; /* enable child scroll areas */
        /* smooth width change when peer panel opens */
        transition: flex-basis 0.35s ease, width 0.35s ease;
      }
      .peer-detail-panel {
        background: #15222c;
        border: 1px solid #20313f;
        border-radius: 18px;
        padding: 20px 24px 26px;
        display: flex; /* keep in flow, but collapsed by default */
        flex-direction: column; /* ensure header stacks above fields (fix layout) */
        gap: 16px;
        box-shadow: 0 0 0 1px #1f2c38 inset, 0 8px 26px -12px #000;
        position: relative;
        opacity: 0;
        transform: translateX(20px);
        pointer-events: none;
        max-height: 100%;
        overflow: auto;
        /* fully hidden by default so it does not reserve layout space */
        display: none;
        flex: 0 0 auto;
        width: 0;
        max-width: 0;
        flex-basis: 0;
        /* animate only when shown */
        transition: opacity 0.3s ease, transform 0.35s ease;
      }
      /* When region has peer-open, we show and size the panel */
      .details-region.peer-open .peer-detail-panel {
        display: flex;
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
        flex-basis: 500px;
        max-width: 500px;
        width: 500px;
      }
      /* Explicit hidden helper (legacy calls) */
      .peer-detail-panel.hidden {
        display: none !important;
      }
      /* Compact island tweaks: move interface actions above stats and ensure layout fits tighter */
      .island.expanded:not(.peer-open) .iface-meta-card {
        position: relative;
        padding-right: 220px; /* space for actions block */
      }
      .island.expanded:not(.peer-open) .iface-actions {
        position: absolute;
        top: 16px;
        right: 18px;
        z-index: 1;
      }
      .island.expanded:not(.peer-open) .iface-stats {
        margin-top: 20px;
        width: 780px;
      }
      .peer-detail-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .peer-detail-header h3 {
        margin: 0;
        font-size: 16px;
      }
      .peer-fields {
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-size: 12px;
        /* Ensure consistent right spacing so inputs don't butt against the island edge */
        padding-right: 12px; /* match dual-traffic grid gap */
      }
      .peer-field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .peer-field label {
        text-transform: uppercase;
        font-size: 10px;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      .peer-field input,
      .peer-field textarea {
        background: #0f181f;
        border: 1px solid #24323d;
        color: #d5e2e9;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        width: 100%;
        resize: vertical;
        font-family: monospace;
        letter-spacing: 0.4px;
        box-sizing: border-box; /* keep consistent right margin within container */
      }
      /* Dual traffic fields (force grid to avoid overlap) */
      .peer-field.dual-traffic {
        display: grid !important;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      .peer-field.dual-traffic .traffic-col {
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .peer-field.dual-traffic input {
        width: 100%;
        box-sizing: border-box;
      }
      #detailPublicKey {
        font-size: 11px;
      }
      .peer-field input[readonly],
      .peer-field textarea[readonly] {
        opacity: 0.85;
      }
      .download-btn {
        background: #1f3a4d;
        border: 1px solid #31566f;
        color: #d9e6ed;
        padding: 8px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 12px;
      }
      .download-btn:hover {
        background: #274a63;
      }
      .cog-btn {
        background: #1f3a4d;
        border: 1px solid #31566f;
        color: #d9e6ed;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .cog-btn:hover {
        background: #274a63;
      }
      .status-pill {
        display: inline-block;
        margin-left: 8px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        border: 1px solid transparent;
        vertical-align: middle;
      }
      .status-pill.ok {
        background: #113820;
        color: #9cf0b7;
        border-color: #2e6b41;
      }
      .status-pill.bad {
        background: #3a1b1b;
        color: #ffb3b3;
        border-color: #6b2e2e;
      }
      .status-pill.small {
        font-size: 10px;
        padding: 1px 6px;
      }
      .peers-section-header {
        display: flex;
        align-items: center;
        /* Use natural flow; right controls will push via auto margin */
      }
      .peers-section-header .peer-tools {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-right: 2px; /* subtle right breathing room */
      }
      .peers-section-header h3 {
        margin: 0;
        font-size: 16px;
      }
      .peer-search {
        background: #162633;
        border: 1px solid #223444;
        color: #d5e2e9;
        padding: 10px 14px;
        border-radius: 10px;
        font-size: 14px;
        width: 220px;
      }
      .peer-list {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
        min-width: 590px;
        overflow-y: auto; /* scroll when many peers */
        max-height: 420px;
        padding-right: 6px; /* keep scrollbar off content */
      }
      .peer-row {
        padding: 12px 14px 14px;
        cursor: pointer;
        font-size: 13px;
        color: #cfd8dc;
        display: flex;
        flex-direction: column;
        gap: 6px;
        background: #15202a;
        border: 1px solid #1f2c38;
        border-radius: 14px;
        transition: background 0.25s, border-color 0.25s;
        position: relative;
      }
      .peer-row:hover {
        background: #1d2c38;
      }
      .peer-row.active {
        background: #27455e;
        border-color: #335d7a;
      }
      .peer-row .line1 {
        display: flex;
        justify-content: space-between;
        font-weight: 500;
      }
      .peer-row .line2 {
        font-size: 11px;
        color: #90a4ae;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .empty-state {
        font-size: 13px;
        color: #7f95a1;
        padding: 10px 4px;
      }
      #peerEditor {
        display: none !important;
      }
      /* Add Peer modal */
      .peer-add-btn {
        width: 38px;
        height: 38px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: 600;
        padding: 0;
        border-radius: 12px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #d8e4ec;
      }
      .peer-add-btn:hover {
        background: #243643;
      }
      .peer-modal-overlay {
        position: fixed;
        inset: 0;
        backdrop-filter: blur(6px);
        background: rgba(10, 15, 20, 0.72);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 900;
        min-height: 100vh;
        overflow-y: auto;
      }
      .peer-modal {
        background: #0f181f;
        border: 1px solid #22323f;
        border-radius: 20px;
        padding: 30px 34px 32px;
        width: 400px;
        max-width: 92%;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: 0 20px 60px -20px #000, 0 0 0 1px #18242e inset;
        margin: auto;
        max-height: 90vh;
        overflow-y: auto;
      }
      .peer-modal h3 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.5px;
      }
      /* Shimmer loading for inputs */
      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
      .input-loading {
        color: transparent !important;
        background-image: linear-gradient(
          90deg,
          #132028 25%,
          #1b2b36 50%,
          #132028 75%
        ) !important;
        background-size: 200% 100% !important;
        animation: shimmer 1.2s linear infinite;
      }
      .input-loading::placeholder {
        color: transparent !important;
      }
      .pm-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .pm-field label {
        font-size: 11px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .pm-field input {
        background: #132028;
        border: 1px solid #243541;
        color: #d9e5ec;
        padding: 12px 14px;
        border-radius: 10px;
        font-size: 14px;
      }
      .pm-field input:focus {
        outline: 2px solid #335d7a;
        outline-offset: 1px;
      }
      .pm-actions {
        display: flex;
        justify-content: flex-end;
        gap: 14px;
        margin-top: 6px;
      }
      .btn-danger {
        background: linear-gradient(135deg, #4d1b21, #2a0d11);
        border: 1px solid #682b33;
        color: #f2d8da;
        box-shadow: 0 0 0 0 rgba(255, 70, 70, 0.25);
      }
      .btn-danger:hover {
        background: linear-gradient(135deg, #5d2027, #351017);
        box-shadow: 0 0 12px -2px rgba(255, 70, 70, 0.35);
      }
      .btn-danger:active {
        transform: translateY(1px);
      }
      .peer-modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #9fb3bf;
        width: 34px;
        height: 34px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .peer-modal-close:hover {
        background: #27455e;
        color: #fff;
      }
      @media (max-width: 1100px) {
        .island-wrapper {
          min-height: 200px;
        }
        .island.expanded {
          flex-direction: column;
        }
        /* On small screens, compact and expanded peer-open share the same full-width behavior */
        .island.expanded,
        .island.expanded.peer-open {
          max-width: 100%;
          min-height: unset;
        }
        .island.expanded .interfaces-panel {
          width: 100%;
          border-right: none;
          border-top: 1px solid #1f2c38;
          border-radius: 0 0 26px 26px;
          box-shadow: none;
          padding: 20px 18px 26px;
          margin-top: 12px;
        }
        .island.expanded .details-region {
          margin-left: 0;
        }
        .peers-layout {
          flex-direction: column;
        }
        .peer-detail-panel {
          /* on small screens, slide down and occupy full width when open */
          transform: translateY(20px);
          max-height: none;
        }
        .details-region.peer-open .peer-detail-panel {
          flex-basis: 100%;
          max-width: 100%;
          width: 100%;
        }
        /* Reset absolute actions on mobile to avoid overlap */
        .island.expanded:not(.peer-open) .iface-meta-card {
          padding-right: 22px;
        }
        .island.expanded:not(.peer-open) .iface-actions {
          position: static;
          margin-left: auto;
        }
        .peer-list {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        }
      }
      /* Status bar (toast) */
      .toast {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        min-width: -moz-available; /* Firefox available width */
        /* optional fallbacks */
        width: -webkit-fill-available;
        max-width: 100%;
        margin: 0 auto;
        z-index: 1000;
        text-align: center;
        color: #e9f0f6;
        border-top: 1px solid #1f2c38;
        backdrop-filter: blur(4px);
        border-radius: 10px 10px 0 0;
        box-shadow: 0 -8px 26px -16px rgba(0, 0, 0, 0.6);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }
      /* Settings modal styles */
      .settings-modal {
        background: #0f181f;
        border: 1px solid #22323f;
        border-radius: 22px;
        width: 720px;
        max-width: 95%;
        display: flex;
        flex-direction: row;
        gap: 0;
        min-height: 420px;
        max-height: 85vh;
        overflow: hidden;
        position: relative;
        box-shadow: 0 18px 48px -20px #000, 0 0 0 1px #18242e inset;
      }
      .settings-left {
        width: 200px;
        background: #101d27;
        border-right: 1px solid #1f2c38;
        display: flex;
        flex-direction: column;
        padding: 24px 0 8px;
        gap: 4px;
      }
      .settings-left h4 {
        margin: 0 18px 10px;
        font-size: 12px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .settings-nav {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .settings-nav li {
        cursor: pointer;
        padding: 10px 18px;
        font-size: 13px;
        color: #cfd8dc;
        border-left: 3px solid transparent;
        transition: background 0.25s, border-color 0.25s;
      }
      .settings-nav li:hover {
        background: #162633;
      }
      .settings-nav li.active {
        background: #1d2c38;
        border-color: #335d7a;
        color: #fff;
      }
      .settings-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 30px 34px 34px;
        overflow-y: auto;
        gap: 24px;
      }
      .settings-content h3 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.5px;
      }
      .settings-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #9fb3bf;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .settings-close-btn:hover {
        background: #27455e;
        color: #fff;
      }
      .settings-form {
        display: flex;
        flex-direction: column;
        gap: 18px;
        max-width: 420px;
      }
      .settings-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .settings-field label {
        font-size: 11px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .settings-field input {
        background: #132028;
        border: 1px solid #243541;
        color: #d9e5ec;
        padding: 12px 14px;
        border-radius: 10px;
        font-size: 14px;
      }
      .settings-field input:focus {
        outline: 2px solid #335d7a;
        outline-offset: 1px;
      }
      #cpFeedback {
        font-size: 12px;
        min-height: 18px;
        color: #a0b4c0;
        white-space: pre-wrap;
        word-break: break-word;
      }
      @media (max-width: 760px) {
        .settings-modal {
          flex-direction: column;
          width: 100%;
        }
        .settings-left {
          width: 100%;
          flex-direction: row;
          overflow-x: auto;
          border-right: none;
          border-bottom: 1px solid #1f2c38;
          padding: 14px 10px;
        }
        .settings-nav {
          flex-direction: row;
        }
        .settings-nav li {
          border-left: none;
          border-bottom: 3px solid transparent;
        }
        .settings-nav li.active {
          border-bottom-color: #335d7a;
        }
      }
      /* Copy button styling for interface success modal */
      .pg-copy-wrap {
        position: relative;
      }
      .pg-copy-btn {
        position: absolute;
        top: 4px;
        right: 6px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #cfd8dc;
        font-size: 11px;
        padding: 3px 8px 4px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
        line-height: 1;
      }
      .pg-copy-btn:hover {
        background: #27455e;
        color: #fff;
      }
      .pg-copy-btn.copied {
        background: #113820;
        border-color: #1e6b39;
        color: #9cf0b7;
      }
      .pg-code-block {
        position: relative;
        margin: 6px 0 4px;
      }
      .pg-code-block code {
        display: block;
        padding: 6px 8px;
        background: #132028;
        border: 1px solid #22323f;
        border-radius: 6px;
        font-size: 12px;
        white-space: pre;
        overflow-x: auto;
      }
      .pg-fixed-btn {
        min-width: 120px;
      }
    </style>
  </head>
  <body>
    <div class="top-bar">
      <div class="logo-title">
        <img
          src="/static/img/logo-transparent.png"
          class="logo-small"
          alt="PyGuard"
        />
        <h1>PyGuard</h1>
      </div>
      <div
        class="top-bar-right"
        style="display: flex; align-items: center; gap: 14px"
      >
        <span
          id="current-interface-label"
          style="font-size: 12px; color: #90a4ae"
        ></span>
        <button id="btnOpenSettings" class="cog-btn" title="Settings">
          Settings
        </button>
        <a class="logout" href="/logout">Logout</a>
      </div>
    </div>
    <div class="island-wrapper">
      <div class="island" id="island">
        <div class="interfaces-panel" id="interfacesPanel">
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 8px;
            "
          >
            <h3>Interfaces</h3>
            <button
              id="btnOpenAddInterface"
              class="peer-add-btn btn-pop"
              title="Add Interface"
            >
              +
            </button>
          </div>
          <div class="iface-list" id="interfacesContainer"></div>
        </div>
        <div class="details-region" id="detailsRegion">
          <div
            class="details-col"
            style="
              display: flex;
              flex-direction: column;
              gap: 24px;
              flex: 1;
              min-width: 0;
            "
          >
            <div class="iface-meta-card" id="serverMetaCard">
              <div class="iface-meta-left">
                <div style="display: flex; align-items: center; gap: 8px">
                  <h2 id="ifaceTitle" style="margin: 0">Select an interface</h2>
                  <span
                    id="ifaceActivePill"
                    class="status-pill bad"
                    style="display: none"
                    >inactive</span
                  >
                </div>
                <div class="iface-stats" id="ifaceStats"></div>
              </div>
              <div class="iface-actions">
                <button id="btnRefresh" class="cog-btn" title="Refresh">
                  Refresh
                </button>
                <button
                  id="btnEnableService"
                  class="cog-btn"
                  title="Enable service"
                >
                  Enable
                </button>
                <button
                  id="btnDisableService"
                  class="cog-btn"
                  title="Disable service"
                >
                  Disable
                </button>
                <button
                  id="btnServerSettings"
                  class="cog-btn"
                  title="Edit server"
                >
                  Edit
                </button>
                <button
                  id="btnDeleteInterface"
                  class="btn-danger"
                  title="Delete Interface"
                >
                  Delete
                </button>
              </div>
            </div>
            <div class="peers-section">
              <div class="peers-layout">
                <div class="peers-left">
                  <div class="peers-section-header">
                    <div style="display: flex; align-items: center; gap: 8px">
                      <h3>Peers</h3>
                      <span
                        class="saving-indicator"
                        id="peerLoading"
                        style="display: none; font-size: 12px; color: #90a4ae"
                        >Loading...</span
                      >
                    </div>
                    <div class="peer-tools">
                      <span
                        id="emptyState"
                        class="empty-state"
                        style="padding: 0 4px; font-size: 12px; color: #7f95a1"
                      >
                        Select peer to display details.
                      </span>
                      <button
                        id="btnOpenAddPeer"
                        class="peer-add-btn btn-pop"
                        title="Add Peer"
                      >
                        +
                      </button>
                      <input
                        id="peerSearch"
                        class="peer-search"
                        type="text"
                        placeholder="Search"
                      />
                    </div>
                  </div>
                  <div id="peersContainer" class="peer-list"></div>
                </div>
                <div class="peer-detail-panel hidden" id="peerDetailPanel">
                  <div class="peer-detail-header" style="gap: 10px">
                    <h3 id="peerDetailTitle" style="flex: 1">Peer</h3>
                    <span
                      id="peerDetailStatusPill"
                      class="status-pill small"
                      style="display: none"
                      >offline</span
                    >
                    <div
                      class="peer-detail-actions"
                      style="display: flex; gap: 8px"
                    >
                      <button
                        class="download-btn"
                        id="btnDeletePeer"
                        title="Delete peer"
                      >
                        Delete
                      </button>
                      <button
                        class="download-btn"
                        id="btnEditPeer"
                        title="Edit peer"
                      >
                        Edit
                      </button>
                      <button
                        class="download-btn"
                        id="btnQrPeer"
                        title="Show QR code"
                      >
                        QR
                      </button>
                      <button
                        class="download-btn"
                        id="btnDownloadPeer"
                        title="Download peer config"
                      >
                        Download
                      </button>
                    </div>
                  </div>
                  <div class="peer-fields" id="peerFields">
                    <div class="peer-field">
                      <label>Public Key</label
                      ><input id="detailPublicKey" readonly />
                    </div>
                    <div class="peer-field dual-traffic">
                      <div class="traffic-col">
                        <label>IP</label><input id="detailIP" readonly />
                      </div>
                      <div class="traffic-col">
                        <label>Endpoint</label
                        ><input id="detailEndpoint" readonly />
                      </div>
                    </div>
                    <div class="peer-field dual-traffic">
                      <div class="traffic-col">
                        <label>Download</label
                        ><input id="detailDownload" readonly />
                      </div>
                      <div class="traffic-col">
                        <label>Upload</label
                        ><input id="detailUpload" readonly />
                      </div>
                    </div>
                    <div class="peer-field">
                      <label>Last Handshake</label
                      ><input id="detailHandshake" readonly />
                    </div>
                    <div class="peer-field">
                      <label>Config</label
                      ><textarea id="detailConfig" rows="8" readonly></textarea>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="toast" id="toast"></div>
    <div id="addInterfaceModal" style="display: none"></div>
    <div id="addPeerModal" style="display: none"></div>
    <div id="qrPeerModal" style="display: none"></div>
    <div id="editPeerModal" style="display: none"></div>
    <div id="editInterfaceModal" style="display: none"></div>
    <div id="deletePeerModal" style="display: none"></div>
    <div id="deleteInterfaceModal" style="display: none"></div>
    <div id="logoutModal" style="display: none"></div>
    <div id="interfaceSuccessModal" style="display: none"></div>
    <div id="settingsModal" style="display: none"></div>
    <script>
      // Unified app mode: direct API (same origin) no /proxy needed
      const apiBase = ""; // empty = root
      console.log(
        "[PyGuard] Dashboard script start (unified mode). apiBase=",
        apiBase
      );
      const headers = () => ({
        "Content-Type": "application/json",
      });
      const interfacesContainer = document.getElementById(
        "interfacesContainer"
      );
      const ifaceTitle = document.getElementById("ifaceTitle");
      const ifaceMeta = document.getElementById("ifaceStats");
      const ifaceActivePill = document.getElementById("ifaceActivePill");
      const islandEl = document.getElementById("island");
      const logoTitle = document.querySelector(".top-bar .logo-title");
      const peersContainer = document.getElementById("peersContainer");
      const peerLoading = document.getElementById("peerLoading");
      const emptyState = document.getElementById("emptyState");
      const peerDetailPanel = document.getElementById("peerDetailPanel");
      // Updated hide/show helpers: rely on .details-region.peer-open to control sizing so when hidden it occupies zero space.
      function hidePeerDetailPanel() {
        if (!peerDetailPanel) return;
        peerDetailPanel.classList.add("hidden");
        const region = islandEl.querySelector(".details-region");
        if (region) region.classList.remove("peer-open");
        islandEl.classList.remove("peer-open");
      }
      function showPeerDetailPanel() {
        if (!peerDetailPanel) return;
        peerDetailPanel.classList.remove("hidden");
        const region = islandEl.querySelector(".details-region");
        if (region) region.classList.add("peer-open");
        islandEl.classList.add("peer-open");
      }
      const editInterfaceModalMount =
        document.getElementById("editInterfaceModal");
      const btnServerSettings = document.getElementById("btnServerSettings");
      const peerDetailTitle = document.getElementById("peerDetailTitle");
      const peerDetailStatusPill = document.getElementById(
        "peerDetailStatusPill"
      );
      const btnDownloadPeer = document.getElementById("btnDownloadPeer");
      const btnEditPeer = document.getElementById("btnEditPeer");
      const btnQrPeer = document.getElementById("btnQrPeer");
      const detailPublicKey = document.getElementById("detailPublicKey");
      const detailIP = document.getElementById("detailIP");
      const detailEndpoint = document.getElementById("detailEndpoint");
      const detailDownload = document.getElementById("detailDownload");
      const detailUpload = document.getElementById("detailUpload");
      const detailHandshake = document.getElementById("detailHandshake");
      const detailConfig = document.getElementById("detailConfig");
      let serverNetwork = "";
      let currentServer = {};
      // Optional (editor not yet rendered in current template revision)
      const peerEditor = document.getElementById("peerEditor");
      const peerForm = document.getElementById("peerForm");
      const peerEditorTitle = document.getElementById("peerEditorTitle");
      const dirtyFlag = document.getElementById("dirtyFlag");
      const toastEl = document.getElementById("toast");
      const peerSearch = document.getElementById("peerSearch");
      const btnRefresh = document.getElementById("btnRefresh");
      const btnAddPeer = document.getElementById("btnAddPeer");
      const btnEnableService = document.getElementById("btnEnableService");
      const btnDisableService = document.getElementById("btnDisableService");
      const btnDeletePeer = document.getElementById("btnDeletePeer");
      const btnDeleteInterface = document.getElementById("btnDeleteInterface");
      const btnCancelEdit = document.getElementById("btnCancelEdit");
      let currentInterface = null;
      let peers = [];
      let originalPeerData = null;
      let currentPeerPublicKey = null;
      let currentPeerName = null;
      let peerDetailInterval = null;
      let lastPeerDetail = null;
      let interfaceRefreshInterval = null;
      let interfacesListInterval = null;
      function clearInterfaceRefreshInterval() {
        if (interfaceRefreshInterval) {
          clearInterval(interfaceRefreshInterval);
          interfaceRefreshInterval = null;
        }
      }
      function clearInterfacesListInterval() {
        if (interfacesListInterval) {
          clearInterval(interfacesListInterval);
          interfacesListInterval = null;
        }
      }
      function clearPeerDetailInterval() {
        if (peerDetailInterval) {
          clearInterval(peerDetailInterval);
          peerDetailInterval = null;
        }
      }
      function showToast(msg, ok = true) {
        toastEl.textContent = msg;
        toastEl.style.background = ok ? "#263844" : "#b71c1c";
        toastEl.classList.add("show");
        setTimeout(() => toastEl.classList.remove("show"), 2800);
      }
      async function fetchJSON(url, opts = {}) {
        try {
          const res = await fetch(url, opts);
          if (res.status === 401) {
            window.location = "/";
            return null;
          }
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(data.detail || res.statusText);
          return data;
        } catch (e) {
          showToast(e.message, false);
          throw e;
        }
      }
      let interfacesFetchInFlight = false;
      function isPeerOnlineFromRuntime(runtime) {
        if (!runtime) return null;
        const s = runtime.last_handshake_str;
        if (!s) return null;
        if (/never/i.test(s)) return false;
        if (
          typeof runtime.last_handshake === "number" &&
          runtime.last_handshake > 600
        )
          return false;
        return true;
      }
      async function loadInterfaces() {
        if (interfacesFetchInFlight) return;
        interfacesFetchInFlight = true;
        let data;
        try {
          data = await fetchJSON(`${apiBase}/interfaces`, {
            headers: headers(),
          });
        } catch (e) {
          console.error("Failed loading interfaces", e);
          interfacesFetchInFlight = false;
          return;
        }
        if (!data) {
          interfacesFetchInFlight = false;
          return;
        }
        const list = data.interfaces || [];
        // Build desired order and metadata
        const desired = list
          .map((obj) => ({
            name: obj && typeof obj === "object" ? obj.name : obj,
            active: obj && typeof obj === "object" ? !!obj.active : false,
          }))
          .filter((x) => !!x.name);

        // Build a map of existing elements
        const existing = new Map();
        Array.from(interfacesContainer.querySelectorAll(".iface-item")).forEach(
          (el) => {
            const n = el.dataset.name;
            if (n) existing.set(n, el);
          }
        );

        // Remove elements that no longer exist
        existing.forEach((el, n) => {
          if (!desired.find((d) => d.name === n)) {
            el.remove();
            existing.delete(n);
          }
        });

        // Ensure each desired item exists and update classes/content minimally
        desired.forEach(({ name, active }) => {
          let el = existing.get(name);
          if (!el) {
            el = document.createElement("div");
            el.className = "iface-item";
            el.dataset.name = name;
            el.onclick = () => selectInterface(name);
            el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
            existing.set(name, el);
          }
          // selection class
          el.classList.toggle("active", name === currentInterface);
          // name text
          const nameSpan = el.querySelector(".iface-name");
          if (nameSpan && nameSpan.textContent !== name)
            nameSpan.textContent = name;
          // status pill
          const pill = el.querySelector(".iface-pill");
          if (pill) {
            pill.classList.toggle("ok", !!active);
            pill.classList.toggle("bad", !active);
            pill.textContent = active ? "active" : "inactive";
            pill.title = active ? "Active" : "Inactive";
          }
        });

        // Reorder DOM to match desired order without full re-render
        desired.forEach(({ name }) => {
          const el = existing.get(name);
          if (el) interfacesContainer.appendChild(el);
        });

        // If no interfaces, show a placeholder once
        if (
          !desired.length &&
          !interfacesContainer.querySelector(".iface-empty")
        ) {
          const ph = document.createElement("div");
          ph.className = "iface-empty";
          ph.style.cssText = "padding:14px 16px;font-size:12px;color:#78909c;";
          ph.textContent = "No interfaces";
          interfacesContainer.appendChild(ph);
        } else if (desired.length) {
          const ph = interfacesContainer.querySelector(".iface-empty");
          if (ph) ph.remove();
        }
        interfacesFetchInFlight = false;
      }
      async function selectInterface(iface) {
        clearPeerDetailInterval();
        clearInterfaceRefreshInterval();
        // Reset any previously selected peer to avoid stale highlight when switching back
        currentPeerPublicKey = null;
        currentPeerName = null;
        lastPeerDetail = null;
        // Hide detail status pill until a peer is opened again
        if (peerDetailStatusPill) peerDetailStatusPill.style.display = "none";
        // Proactively remove any lingering active class from existing rows
        document
          .querySelectorAll(".peer-row.active")
          .forEach((r) => r.classList.remove("active"));
        currentInterface = iface;
        document
          .querySelectorAll(".iface-item")
          .forEach((i) =>
            i.classList.toggle("active", i.dataset.name === iface)
          );
        ifaceTitle.textContent = iface;
        ifaceMeta.innerHTML = "";
        peersContainer.innerHTML = "";
        // Reset to compact (no peer open) when switching/choosing interface
        islandEl.classList.remove("peer-open");
        islandEl
          .querySelector(".details-region")
          ?.classList.remove("peer-open");
        emptyState.style.display = "block";
        islandEl.classList.add("expanded");
        await loadInterfaceAll();
        // Start periodic refresh of interface peers/status every 5s
        interfaceRefreshInterval = setInterval(async () => {
          try {
            await loadInterfaceAll();
          } catch (_) {}
        }, 5000);
      }
      async function loadInterfaceAll() {
        if (!currentInterface) return;
        peerLoading.style.display = "inline";
        try {
          const data = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(currentInterface)}`,
            { headers: headers() }
          );
          if (!data) return;
          const s = data.server || {};
          serverNetwork = s.network || "";
          currentServer = s;
          const isActive = !!data.active;
          // Update active pill next to interface name
          if (ifaceActivePill) {
            ifaceActivePill.style.display = "inline-block";
            ifaceActivePill.classList.toggle("ok", isActive);
            ifaceActivePill.classList.toggle("bad", !isActive);
            ifaceActivePill.textContent = isActive ? "active" : "inactive";
          }
          let peersData = data.peers || {};
          if (typeof peersData === "string") {
            try {
              const parsed = JSON.parse(peersData);
              // legacy format may wrap in { peers: {..} }
              if (parsed && parsed.peers && typeof parsed.peers === "object")
                peersData = parsed.peers;
              else peersData = parsed;
            } catch (e) {
              console.warn("Failed to parse peers JSON string", e);
              peersData = {};
            }
          }
          const peerNames = Object.keys(peersData);
          const peerCount = data.peer_count ?? peerNames.length;
          const stats = [
            { label: "Network", value: s.network || "-" },
            { label: "relay ip", value: s.ip || "—" },
            { label: "Port", value: s.port || "-" },
            { label: "Peers", value: peerCount },
            { label: "Public IP", value: s.public_ip || "—" },
          ];
          ifaceMeta.innerHTML = stats
            .map(
              (st) =>
                `<div class="iface-stat"><span class="label">${st.label}</span><span>${st.value}</span></div>`
            )
            .join("");
          peers = peerNames.map((name) => {
            const info = peersData[name] || {};
            return {
              public_key: info.public_key || name, // in case we add later
              name,
              active: !!info.active,
              last_handshake: info.last_handshake || null,
              last_handshake_str: info.last_handshake_str || "",
              download: info.download || "0 KiB",
              uploaded: info.uploaded || "0 KiB",
            };
          });
          console.debug("Loaded peers (with status)", peers);
          renderPeerList();
        } finally {
          peerLoading.style.display = "none";
        }
      }
      function renderPeerList() {
        const q = peerSearch.value.trim().toLowerCase();
        peersContainer.innerHTML = "";
        const filtered = peers.filter(
          (p) =>
            !q ||
            p.name.toLowerCase().includes(q) ||
            (p.public_key || "").toLowerCase().includes(q)
        );
        if (!filtered.length) {
          peersContainer.innerHTML =
            '<div style="padding:16px;font-size:12px;color:#78909c;">No peers</div>';
          return;
        }
        filtered.forEach((p) => {
          const el = document.createElement("div");
          el.className =
            "peer-row" +
            (p.public_key === currentPeerPublicKey ? " active" : "");
          // Attach identifiers for precise selection
          el.dataset.pubkey = p.public_key || p.name;
          el.dataset.name = p.name;
          const pill = `<span class=\"status-pill small ${
            p.active ? "ok" : "bad"
          }\" title=\"${p.active ? "Online" : "Offline"}\">${
            p.active ? "online" : "offline"
          }</span>`;
          el.innerHTML = `<div class="line1"><span style="display:flex;align-items:center;gap:6px;"><span>${
            p.name
          }</span></span><span>${pill}</span></div><div class="line2"><span>${(
            p.public_key || ""
          ).slice(0, 14)}...</span><span>D:${p.download} U:${
            p.uploaded
          }</span></div>`;
          el.onclick = () => openPeer(p.public_key || p.name);
          peersContainer.appendChild(el);
        });
      }
      function setPeerDetailLoading(loading) {
        const fields = [
          detailPublicKey,
          detailIP,
          detailEndpoint,
          detailDownload,
          detailUpload,
          detailHandshake,
          detailConfig,
        ];
        fields.forEach((el) => {
          if (!el) return;
          if (loading) {
            el.setAttribute("disabled", "true");
            el.setAttribute("aria-busy", "true");
            el.classList.add("input-loading");
          } else {
            el.removeAttribute("disabled");
            el.removeAttribute("aria-busy");
            el.classList.remove("input-loading");
          }
        });
      }
      async function openPeer(pub) {
        const p = peers.find((x) => x.public_key === pub);
        if (!p) return;
        currentPeerPublicKey = pub;
        currentPeerName = p.name;
        clearPeerDetailInterval();
        // Highlight only the exact selected row
        document
          .querySelectorAll(".peer-row")
          .forEach((r) =>
            r.classList.toggle("active", r.dataset.pubkey === pub)
          );
        if (emptyState) emptyState.style.display = "none";
        if (peerEditor) peerEditor.style.display = "block";
        if (peerEditorTitle) peerEditorTitle.textContent = `Peer: ${p.name}`;
        if (peerDetailPanel) {
          islandEl.querySelector(".details-region")?.classList.add("peer-open");
          islandEl.classList.add("peer-open");
          showPeerDetailPanel();
        }
        // Start shimmer loading on peer detail fields
        setPeerDetailLoading(true);
        // Fetch detailed peer info
        try {
          const detail = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/peers/${encodeURIComponent(p.name)}`,
            { headers: headers() }
          );
          if (detail && detail.peer_data) {
            const d = detail.peer_data;
            lastPeerDetail = detail;
            if (peerForm) {
              if (peerForm.peerName) peerForm.peerName.value = p.name;
              if (peerForm.peerAddress) peerForm.peerAddress.value = d.ip || "";
              if (peerForm.peerAllowedIPs)
                peerForm.peerAllowedIPs.value = d.allowed_ips || "";
              if (peerForm.peerEndpoint)
                peerForm.peerEndpoint.value = d.endpoint || "";
              if (peerForm.peerPersistentKeepalive)
                peerForm.peerPersistentKeepalive.value =
                  d.persistent_keepalive || "";
              if (peerForm.peerDNS) peerForm.peerDNS.value = "";
              if (peerForm.peerPrivateKey) peerForm.peerPrivateKey.value = "";
              if (peerForm.peerNotes) peerForm.peerNotes.value = d.notes || "";
            }
            // Read-only meta fields
            const pubKeyEl = document.getElementById("peerPublicKey");
            const serverEpEl = document.getElementById("serverEndpoint");
            if (pubKeyEl)
              pubKeyEl.value =
                d.public_key || detail.public_key || p.public_key || "";
            const ep = detail.server_endpoint_host
              ? `${detail.server_endpoint_host}:${
                  detail.server_port || ""
                }`.replace(/:$/, "")
              : "";
            if (serverEpEl) serverEpEl.value = ep;
            // Populate panel
            if (peerDetailPanel) {
              peerDetailTitle.textContent = p.name;
              detailPublicKey.value = d.public_key || p.public_key || "";
              detailIP.value = d.ip || "";
              detailEndpoint.value = d.endpoint || "";
              const runtime = detail.runtime || {};
              detailDownload.value = runtime.rx_human || p.download || "";
              detailUpload.value = runtime.tx_human || p.uploaded || "";
              detailHandshake.value = runtime.last_handshake_str
                ? runtime.last_handshake_str
                : p.last_handshake_str || "—";
              detailConfig.value =
                detail.config_text || detail.peer_config || "";
              btnDownloadPeer.onclick = () =>
                downloadPeerConfig(
                  p.name,
                  detail.config_text || detail.peer_config || ""
                );
              // update detail status pill
              const online =
                isPeerOnlineFromRuntime(runtime) ?? p.active ? true : false;
              if (peerDetailStatusPill) {
                peerDetailStatusPill.style.display = "inline-block";
                peerDetailStatusPill.classList.toggle("ok", online);
                peerDetailStatusPill.classList.toggle("bad", !online);
                peerDetailStatusPill.textContent = online
                  ? "online"
                  : "offline";
                peerDetailStatusPill.title = online ? "Online" : "Offline";
              }
            }
          } else {
            lastPeerDetail = null;
            if (peerForm) {
              if (peerForm.peerName) peerForm.peerName.value = p.name;
              if (peerForm.peerAddress) peerForm.peerAddress.value = "";
              if (peerForm.peerAllowedIPs) peerForm.peerAllowedIPs.value = "";
              if (peerForm.peerEndpoint) peerForm.peerEndpoint.value = "";
              if (peerForm.peerPersistentKeepalive)
                peerForm.peerPersistentKeepalive.value = "";
              if (peerForm.peerDNS) peerForm.peerDNS.value = "";
              if (peerForm.peerPrivateKey) peerForm.peerPrivateKey.value = "";
              if (peerForm.peerNotes) peerForm.peerNotes.value = "";
            }
            const pubKeyEl = document.getElementById("peerPublicKey");
            const serverEpEl = document.getElementById("serverEndpoint");
            if (pubKeyEl) pubKeyEl.value = p.public_key || "";
            if (serverEpEl) serverEpEl.value = "";
            if (peerDetailPanel) {
              peerDetailTitle.textContent = p.name;
              detailPublicKey.value = p.public_key || "";
              detailIP.value = "";
              detailEndpoint.value = "";
              detailDownload.value = p.download || "";
              detailUpload.value = p.uploaded || "";
              detailHandshake.value = p.last_handshake_str || "—";
              detailConfig.value = "";
              btnDownloadPeer.onclick = () => showToast("No config yet", false);
              if (peerDetailStatusPill) {
                peerDetailStatusPill.style.display = "inline-block";
                peerDetailStatusPill.classList.toggle("ok", !!p.active);
                peerDetailStatusPill.classList.toggle("bad", !p.active);
                peerDetailStatusPill.textContent = p.active
                  ? "online"
                  : "offline";
                peerDetailStatusPill.title = p.active ? "Online" : "Offline";
              }
            }
          }
        } catch (e) {
          /* toast already shown */
        } finally {
          // End shimmer loading regardless of outcome
          setPeerDetailLoading(false);
        }
        originalPeerData = serializeForm();
        if (dirtyFlag) dirtyFlag.style.display = "none";
        // Start periodic refresh (every 5s)
        peerDetailInterval = setInterval(
          () => refreshCurrentPeerRuntime(),
          5000
        );
      }
      async function refreshCurrentPeerRuntime() {
        if (!currentInterface || !currentPeerName) return;
        try {
          const detail = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/peers/${encodeURIComponent(currentPeerName)}`,
            { headers: headers() }
          );
          if (!detail || !detail.peer_data) return;
          const runtime = detail.runtime || {};
          // Update endpoint (unlikely to change often but keep fresh)
          if (detail?.peer_data?.endpoint && detailEndpoint) {
            detailEndpoint.value = detail.peer_data.endpoint;
          }
          // Update peer detail panel fields if still selected
          if (peerDetailTitle.textContent.trim() === currentPeerName) {
            // traffic + handshake
            detailDownload.value =
              runtime.rx_human ||
              detail.peer_data.download ||
              detail.peer_data.transfer_rx_bytes_human ||
              "";
            detailUpload.value =
              runtime.tx_human ||
              detail.peer_data.uploaded ||
              detail.peer_data.transfer_tx_bytes_human ||
              "";
            detailHandshake.value =
              runtime.last_handshake_str ||
              detail.peer_data.last_handshake_str ||
              "—";
          }
          // Update peers array entry & list row
          const idx = peers.findIndex((pr) => pr.name === currentPeerName);
          if (idx >= 0) {
            peers[idx].last_handshake_str =
              runtime.last_handshake_str || peers[idx].last_handshake_str;
            // Reconstruct download/upload from runtime if available (choose rx/tx_human or keep previous)
            if (runtime.rx_human && runtime.tx_human) {
              peers[idx].download = runtime.rx_human;
              peers[idx].uploaded = runtime.tx_human;
            }
            peers[idx].active = runtime.last_handshake_str
              ? !/never/i.test(runtime.last_handshake_str) &&
                !(runtime.last_handshake && runtime.last_handshake > 600)
              : peers[idx].active;
          }
          // Update DOM row for current peer
          const rows = peersContainer.querySelectorAll(".peer-row");
          rows.forEach((row) => {
            const nameEl = row.querySelector(".line1 span span");
            if (nameEl && nameEl.textContent === currentPeerName) {
              const line2 = row.querySelector(".line2");
              if (line2) {
                const peerObj = peers[idx];
                line2.innerHTML = `<span>${(peerObj.public_key || "").slice(
                  0,
                  14
                )}...</span><span>D:${peerObj.download} U:${
                  peerObj.uploaded
                }</span>`;
              }
              const pillEl = row.querySelector(".status-pill");
              if (pillEl) {
                pillEl.classList.toggle("ok", peers[idx].active);
                pillEl.classList.toggle("bad", !peers[idx].active);
                pillEl.textContent = peers[idx].active ? "online" : "offline";
                pillEl.title = peers[idx].active ? "Online" : "Offline";
              }
            }
          });
          // Update detail header pill as well
          const online =
            isPeerOnlineFromRuntime(runtime) ?? peers[idx]?.active
              ? true
              : false;
          if (peerDetailStatusPill) {
            peerDetailStatusPill.style.display = "inline-block";
            peerDetailStatusPill.classList.toggle("ok", online);
            peerDetailStatusPill.classList.toggle("bad", !online);
            peerDetailStatusPill.textContent = online ? "online" : "offline";
            peerDetailStatusPill.title = online ? "Online" : "Offline";
          }
        } catch (e) {
          /* ignore refresh errors */
        }
      }
      function downloadPeerConfig(name, text) {
        if (!text) {
          showToast("Config empty", false);
          return;
        }
        const blob = new Blob([text], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${name}.conf`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(a.href);
          a.remove();
        }, 1200);
        showToast("Config downloaded");
      }
      function serializeForm() {
        if (!peerForm) return {};
        return {
          name: peerForm.peerName?.value.trim() || "",
          address: peerForm.peerAddress?.value.trim() || "",
          allowed_ips: peerForm.peerAllowedIPs?.value.trim() || "",
          endpoint: peerForm.peerEndpoint?.value.trim() || "",
          persistent_keepalive:
            peerForm.peerPersistentKeepalive?.value.trim() || "",
          dns: peerForm.peerDNS?.value.trim() || "",
          private_key: peerForm.peerPrivateKey?.value.trim() || "",
          notes: peerForm.peerNotes?.value.trim() || "",
        };
      }
      function detectDirty() {
        if (!peerForm || !originalPeerData || !dirtyFlag) return;
        const now = serializeForm();
        const dirty = Object.keys(now).some(
          (k) => now[k] !== originalPeerData[k]
        );
        dirtyFlag.style.display = dirty ? "inline" : "none";
      }
      if (peerForm) {
        peerForm.addEventListener("input", detectDirty);
        peerForm.addEventListener("submit", (e) => {
          e.preventDefault();
          showToast("Peer save not implemented yet", false);
        });
      }
      // Delete peer modal wiring
      const deletePeerModalMount = document.getElementById("deletePeerModal");
      const deleteInterfaceModalMount = document.getElementById(
        "deleteInterfaceModal"
      );
      function buildDeletePeerModal(name) {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="dpmClose" aria-label="Close">×</button>\n    <h3>Delete Peer</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to delete peer <b>${name}</b>?</div>\n    <div id="dpmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0; margin-top:8px;"></div>\n    <div class="pm-actions">\n      <button type="button" id="dpmCancel" class="btn-press">Cancel</button>\n      <button type="button" id="dpmDelete" class="btn-danger btn-press">Delete</button>\n    </div>\n  </div>\n</div>`;
      }
      async function openDeletePeerModal() {
        if (!currentInterface || !currentPeerName) {
          showToast("Select a peer first", false);
          return;
        }
        deletePeerModalMount.innerHTML = buildDeletePeerModal(currentPeerName);
        deletePeerModalMount.style.display = "block";
        const overlay = deletePeerModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = deletePeerModalMount.querySelector("#dpmClose");
        const btnCancel = deletePeerModalMount.querySelector("#dpmCancel");
        const btnGo = deletePeerModalMount.querySelector("#dpmDelete");
        const feedback = deletePeerModalMount.querySelector("#dpmFeedback");
        function close() {
          deletePeerModalMount.style.display = "none";
          deletePeerModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnGo.onclick = async () => {
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Deleting...";
          try {
            const res = await fetch(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/${encodeURIComponent(currentPeerName)}/delete`,
              { method: "POST", headers: headers() }
            );
            if (!res.ok) {
              const d = await res.json().catch(() => ({}));
              throw new Error(d.detail || res.statusText);
            }
            close();
            showToast("Peer deleted");
            clearPeerDetailInterval();
            currentPeerPublicKey = null;
            currentPeerName = null;
            lastPeerDetail = null;
            const detailsRegion = islandEl.querySelector(".details-region");
            if (detailsRegion) detailsRegion.classList.remove("peer-open");
            islandEl.classList.remove("peer-open");
            hidePeerDetailPanel();
            // Refresh peers
            await loadInterfaceAll();
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Delete failed"}`;
          }
        };
      }
      if (btnDeletePeer) btnDeletePeer.onclick = openDeletePeerModal;
      // Delete interface modal wiring (mirrors peer deletion)
      function buildDeleteInterfaceModal(name) {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="dimClose" aria-label="Close">×</button>\n    <h3>Delete Interface</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to delete interface <b>${name}</b>? This will remove its config and peers.</div>\n    <div id="dimFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0; margin-top:8px;"></div>\n    <div class="pm-actions">\n      <button type="button" id="dimCancel" class="btn-press">Cancel</button>\n      <button type="button" id="dimDelete" class="btn-danger btn-press">Delete</button>\n    </div>\n  </div>\n</div>`;
      }
      async function openDeleteInterfaceModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        deleteInterfaceModalMount.innerHTML =
          buildDeleteInterfaceModal(currentInterface);
        deleteInterfaceModalMount.style.display = "block";
        const overlay = deleteInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = deleteInterfaceModalMount.querySelector("#dimClose");
        const btnCancel = deleteInterfaceModalMount.querySelector("#dimCancel");
        const btnGo = deleteInterfaceModalMount.querySelector("#dimDelete");
        const feedback =
          deleteInterfaceModalMount.querySelector("#dimFeedback");
        function close() {
          deleteInterfaceModalMount.style.display = "none";
          deleteInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnGo.onclick = async () => {
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Deleting...";
          try {
            const name = currentInterface;
            const res = await fetch(
              `${apiBase}/interfaces/${encodeURIComponent(name)}/delete`,
              { method: "POST", headers: headers() }
            );
            if (!res.ok) {
              const d = await res.json().catch(() => ({}));
              throw new Error(d.detail || res.statusText);
            }
            const payload = await res.json().catch(() => ({}));
            // Update interface list from response
            const list = Array.isArray(payload?.interfaces)
              ? payload.interfaces
              : [];
            const desired = list
              .map((obj) => ({
                name: obj && typeof obj === "object" ? obj.name : obj,
                active: obj && typeof obj === "object" ? !!obj.active : false,
              }))
              .filter((x) => !!x.name);
            const existing = new Map();
            Array.from(
              interfacesContainer.querySelectorAll(".iface-item")
            ).forEach((el) => {
              const n = el.dataset.name;
              if (n) existing.set(n, el);
            });
            // Remove deleted element (if still present)
            existing.forEach((el, n) => {
              if (!desired.find((d) => d.name === n)) {
                el.remove();
                existing.delete(n);
              }
            });
            desired.forEach(({ name, active }) => {
              let el = existing.get(name);
              if (!el) {
                el = document.createElement("div");
                el.className = "iface-item";
                el.dataset.name = name;
                el.onclick = () => selectInterface(name);
                el.innerHTML = `<span class=\"iface-name\"></span><span class=\"iface-pill status-pill small\"></span>`;
                existing.set(name, el);
              }
              el.classList.toggle("active", false);
              const ns = el.querySelector(".iface-name");
              if (ns && ns.textContent !== name) ns.textContent = name;
              const pill = el.querySelector(".iface-pill");
              if (pill) {
                pill.classList.toggle("ok", !!active);
                pill.classList.toggle("bad", !active);
                pill.textContent = active ? "active" : "inactive";
                pill.title = active ? "Active" : "Inactive";
              }
              interfacesContainer.appendChild(el);
            });
            // Show placeholder when empty
            let ph = interfacesContainer.querySelector(".iface-empty");
            if (desired.length === 0) {
              if (!ph) {
                ph = document.createElement("div");
                ph.className = "iface-empty";
                ph.style.cssText =
                  "padding:14px 16px;font-size:12px;color:#78909c;";
                ph.textContent = "No interfaces";
                interfacesContainer.appendChild(ph);
              }
            } else if (ph) {
              ph.remove();
            }
            // Deselect current interface and reverse selection animation
            const detailsRegion = islandEl.querySelector(".details-region");
            if (detailsRegion) {
              detailsRegion.classList.remove("peer-open");
            }
            islandEl.classList.remove("peer-open");
            hidePeerDetailPanel();
            islandEl.classList.remove("expanded");
            ifaceTitle.textContent = "";
            ifaceMeta.innerHTML = "";
            peersContainer.innerHTML = "";
            emptyState.style.display = "block";
            clearPeerDetailInterval();
            clearInterfaceRefreshInterval();
            document
              .querySelectorAll(".iface-item")
              .forEach((i) => i.classList.remove("active"));
            currentInterface = null;
            close();
            showToast("Interface deleted");
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Delete failed"}`;
          }
        };
      }
      if (btnDeleteInterface)
        btnDeleteInterface.onclick = openDeleteInterfaceModal;
      if (btnEnableService)
        btnEnableService.onclick = async () => {
          if (!currentInterface) {
            showToast("Select an interface first", false);
            return;
          }
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/service/enable`,
              { method: "POST", headers: headers() }
            );
            // Update interface list using returned data if present
            if (res && Array.isArray(res.data)) {
              // Minimal: force a refresh by rebuilding with returned list
              // Build a fake response to feed existing loadInterfaces logic
              const list = res.data;
              // Update DOM directly similar to loadInterfaces diff routine
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            // Also refresh current interface summary to update active pill
            await loadInterfaceAll();
            showToast("Service enabled");
          } catch (e) {
            /* toast already shown */
          }
        };
      if (btnDisableService)
        btnDisableService.onclick = async () => {
          if (!currentInterface) {
            showToast("Select an interface first", false);
            return;
          }
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/service/disable`,
              { method: "POST", headers: headers() }
            );
            if (res && Array.isArray(res.data)) {
              const list = res.data;
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class=\"iface-name\"></span><span class=\"iface-pill status-pill small\"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            await loadInterfaceAll();
            showToast("Service disabled");
          } catch (e) {
            /* toast already shown */
          }
        };
      // Add Peer modal logic
      const addInterfaceModalMount =
        document.getElementById("addInterfaceModal");
      const addPeerModalMount = document.getElementById("addPeerModal");
      const qrPeerModalMount = document.getElementById("qrPeerModal");
      const editPeerModalMount = document.getElementById("editPeerModal");
      function buildAddPeerModal(ipPrefill) {
        const allowedPrefill = serverNetwork || "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="pmClose" aria-label="Close">×</button>\n    <h3>Add Peer</h3>\n    <form id="pmForm" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="pmName">Peer Name</label>\n        <input id="pmName" name="name" placeholder="e.g. laptop" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="pmIP">Peer IP</label>\n        <input id="pmIP" name="ip" value="${
          ipPrefill || ""
        }" placeholder="Auto if blank"/>\n      </div>\n      <div class="pm-field">\n        <label for="pmAllowed">Allowed IPs</label>\n        <input id="pmAllowed" name="allowed_ips" value="${allowedPrefill}" placeholder="e.g. ${
          allowedPrefill || "0.0.0.0/0"
        }"/>\n      </div>\n      <div id="pmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="pmCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="pmValidate" class="btn-glow">Create</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function ensureServerNetwork() {
        // If we didn't capture the network during interface load, fetch it now.
        if (!currentInterface || serverNetwork) return;
        try {
          const d = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(currentInterface)}`,
            { headers: headers() }
          );
          serverNetwork = d?.server?.network || "";
        } catch (_) {
          /* non-fatal */
        }
      }
      async function fetchNextAvailable() {
        if (!currentInterface) return null;
        try {
          const d = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/next_available`,
            { headers: headers() }
          );
          return d?.next_available_ip || null;
        } catch {
          return null;
        }
      }
      async function openAddPeerModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        // Ensure we have the latest server network to prefill Allowed IPs
        await ensureServerNetwork();
        const ip = await fetchNextAvailable();
        addPeerModalMount.innerHTML = buildAddPeerModal(ip);
        addPeerModalMount.style.display = "block";
        const overlay = addPeerModalMount.querySelector(".peer-modal-overlay");
        const form = addPeerModalMount.querySelector("#pmForm");
        const btnCancel = addPeerModalMount.querySelector("#pmCancel");
        const btnClose = addPeerModalMount.querySelector("#pmClose");
        const feedback = addPeerModalMount.querySelector("#pmFeedback");
        const nameInput = addPeerModalMount.querySelector("#pmName");
        const ipInput = addPeerModalMount.querySelector("#pmIP");
        const allowedInput = addPeerModalMount.querySelector("#pmAllowed");
        nameInput.focus();
        function close() {
          addPeerModalMount.style.display = "none";
          addPeerModalMount.innerHTML = "";
        }
        btnCancel.onclick = close;
        btnClose.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          const name = nameInput.value.trim();
          const ipVal = ipInput.value.trim();
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name required";
            return;
          }
          const allowed = (allowedInput.value || "").trim();
          const payload = ipVal ? { name, ip: ipVal } : { name };
          if (allowed) payload.new_allowed = allowed;
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/validate`,
              {
                method: "POST",
                headers: headers(),
                body: JSON.stringify(payload),
              }
            );
            if (res && res.ok) {
              feedback.style.color = "#32c861";
              feedback.textContent = "Validated. Creating...";
              // Build creation payload expected by API (AddPeerReq)
              const finalIP = ipVal || ip || "";
              const finalAllowed = allowed || serverNetwork || "";
              if (!finalIP) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent =
                  "No available IP; try again or specify an IP.";
                return;
              }
              if (!finalAllowed) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent = "Allowed IPs required; fill the field.";
                return;
              }
              const createBody = {
                name,
                peer_ip: finalIP,
                allowed_ips: finalAllowed,
              };
              try {
                const createRes = await fetch(
                  `${apiBase}/interfaces/${encodeURIComponent(
                    currentInterface
                  )}/peers/add`,
                  {
                    method: "POST",
                    headers: headers(),
                    body: JSON.stringify(createBody),
                  }
                );
                const createdData = await createRes.json().catch(() => ({}));
                if (!createRes.ok) {
                  throw new Error(
                    createdData.detail ||
                      createRes.statusText ||
                      "Create failed"
                  );
                }
                // Update local peers list from returned peers object
                let peersData = createdData || {};
                if (typeof peersData === "string") {
                  try {
                    peersData = JSON.parse(peersData);
                  } catch {
                    peersData = {};
                  }
                }
                const names = Object.keys(peersData);
                peers = names.map((n) => {
                  const info = peersData[n] || {};
                  return {
                    public_key: info.public_key || n,
                    name: n,
                    active: !!info.active,
                    last_handshake: info.last_handshake || null,
                    last_handshake_str: info.last_handshake_str || "",
                    download: info.download || "0 KiB",
                    uploaded: info.uploaded || "0 KiB",
                  };
                });
                renderPeerList();
                // Close modal and select newly created peer
                close();
                showToast("Peer created");
                const createdPeer = peers.find((p) => p.name === name);
                if (createdPeer) {
                  openPeer(createdPeer.public_key || createdPeer.name);
                }
              } catch (err) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent = `Create failed: ${
                  err.message || "error"
                }`;
              }
            } else {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = (res && res.detail) || "Validation failed";
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err.message || "Validation error"
            }`;
          }
        });
      }
      const btnOpenAddPeer = document.getElementById("btnOpenAddPeer");
      const btnOpenAddInterface = document.getElementById(
        "btnOpenAddInterface"
      );
      if (btnOpenAddPeer)
        btnOpenAddPeer.addEventListener("click", openAddPeerModal);
      if (btnAddPeer) btnAddPeer.onclick = openAddPeerModal;
      // Edit Interface modal
      function buildEditInterfaceModal(prefill, loading = false) {
        const name = prefill?.name ?? currentInterface ?? "";
        const port = prefill?.port ?? currentServer?.port ?? "";
        const network = prefill?.network ?? currentServer?.network ?? "";
        const public_ip = prefill?.public_ip ?? currentServer?.public_ip ?? "";
        const dns = prefill?.dns ?? currentServer?.dns ?? "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        const chkDis = loading ? "disabled" : "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="eimClose" aria-label="Close">×</button>\n    <h3>Edit Interface</h3>\n    <form id="eimForm" data-loading="${
          loading ? 1 : 0
        }" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="eimName">Name</label>\n        <input ${dis} class="${cls.trim()}" id="eimName" name="name" value="${name}" placeholder="e.g. wg0" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="eimPort">Port</label>\n        <input ${dis} class="${cls.trim()}" id="eimPort" name="port" value="${port}" placeholder="51820"/>\n      </div>\n      <div class="pm-field">\n        <label for="eimNetwork">Network</label>\n        <input ${dis} class="${cls.trim()}" id="eimNetwork" name="network" value="${network}" placeholder="10.0.0.0/24"/>\n      </div>\n      <div class="pm-field">\n        <label for="eimPublicIP">Public IP</label>\n        <input ${dis} class="${cls.trim()}" id="eimPublicIP" name="public_ip" value="${public_ip}" placeholder="e.g. 203.0.113.10"/>\n      </div>\n      <div class="pm-field">\n        <label for="eimDNS">DNS</label>\n        <input ${dis} class="${cls.trim()}" id="eimDNS" name="dns" value="${dns}" placeholder="e.g. 1.1.1.1"/>\n      </div>\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <input type="checkbox" id="eimIgnore" ${chkDis} checked />\n        <label for="eimIgnore" style="margin:0;">Ignore network range check</label>\n      </div>\n      <div id="eimFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0; white-space:pre-wrap; word-break:break-word;"></div>\n      <div class="pm-actions">\n        <button type="button" id="eimCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="eimValidate" class="btn-glow" style="min-width:150px;">Apply</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function openEditInterfaceModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        if (!editInterfaceModalMount) return;
        // show immediately (no loading fetch needed)
        editInterfaceModalMount.innerHTML = buildEditInterfaceModal({}, false);
        editInterfaceModalMount.style.display = "block";
        const overlay = editInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = editInterfaceModalMount.querySelector("#eimClose");
        const btnCancel = editInterfaceModalMount.querySelector("#eimCancel");
        const form = editInterfaceModalMount.querySelector("#eimForm");
        const feedback = editInterfaceModalMount.querySelector("#eimFeedback");
        const nameInput = editInterfaceModalMount.querySelector("#eimName");
        const portInput = editInterfaceModalMount.querySelector("#eimPort");
        const networkInput =
          editInterfaceModalMount.querySelector("#eimNetwork");
        const publicIpInput =
          editInterfaceModalMount.querySelector("#eimPublicIP");
        const dnsInput = editInterfaceModalMount.querySelector("#eimDNS");
        const ignoreChk = editInterfaceModalMount.querySelector("#eimIgnore");
        function close() {
          editInterfaceModalMount.style.display = "none";
          editInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          // Build ValidateInterface payload (exclude dns and public_ip)
          const newName = (nameInput.value || "").trim();
          const newPortStr = (portInput.value || "").trim();
          const newNetwork = (networkInput.value || "").trim();
          const newPort = newPortStr
            ? parseInt(newPortStr, 10)
            : currentServer?.port ?? 0;
          const body = {
            interface: newName || currentInterface,
            port: Number.isFinite(newPort) ? newPort : currentServer?.port || 0,
            network: newNetwork || currentServer?.network || "",
            ignore_range_check: !!ignoreChk.checked,
            old_interface: currentInterface,
            old_port: currentServer?.port ?? null,
            old_network: currentServer?.network ?? null,
          };
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          try {
            const res = await fetch(`${apiBase}/interfaces/validate`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(body),
            });
            const text = await res.text();
            let json;
            try {
              json = JSON.parse(text);
            } catch {
              json = { raw: text };
            }
            if (!res.ok) {
              feedback.style.color = "#ff6b6b";
              feedback.textContent =
                typeof json === "object" && json?.detail
                  ? `Error: ${json.detail}`
                  : `Error: ${text}`;
              return;
            }
            feedback.style.color = "#9cf0b7";
            feedback.textContent = "Validated succesfuly";

            // On successful validation, apply changes via server/update
            const updBody = {
              // include only non-empty new values; backend compares against old_* to decide
              name:
                newName && newName !== currentInterface ? newName : undefined,
              port: Number.isFinite(newPort) ? newPort : undefined,
              network: newNetwork ? newNetwork : undefined,
              public_ip: (publicIpInput?.value || "").trim() || undefined,
              dns: (dnsInput?.value || "").trim() || undefined,
              old_port: currentServer?.port ?? null,
              old_dns: currentServer?.dns ?? null,
              old_public_ip: currentServer?.public_ip ?? null,
              old_network: currentServer?.network ?? null,
            };
            feedback.style.color = "#32c861";
            feedback.textContent = "Validated. Applying changes...";
            try {
              const updRes = await fetch(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/server/update`,
                {
                  method: "POST",
                  headers: headers(),
                  body: JSON.stringify(updBody),
                }
              );
              const updPayload = await updRes.json().catch(() => ({}));
              if (!updRes.ok) {
                throw new Error(
                  updPayload?.detail || updRes.statusText || "Update failed"
                );
              }
              // Update interface list UI using returned list
              const list = Array.isArray(updPayload?.interfaces)
                ? updPayload.interfaces
                : [];
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              // Remove items no longer present
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
              // Determine final selected interface name (may have changed)
              const updatedName =
                updPayload?.interface || newName || currentInterface;
              currentInterface = updatedName;
              // Update selection highlight
              document
                .querySelectorAll(".iface-item")
                .forEach((i) =>
                  i.classList.toggle("active", i.dataset.name === updatedName)
                );
              // Update header and stats from new_data
              const nd = updPayload?.new_data || {};
              const s = nd.server || {};
              serverNetwork = s.network || "";
              currentServer = s;
              ifaceTitle.textContent = updatedName;
              // active pill
              const isActive = !!nd.active;
              if (ifaceActivePill) {
                ifaceActivePill.style.display = "inline-block";
                ifaceActivePill.classList.toggle("ok", isActive);
                ifaceActivePill.classList.toggle("bad", !isActive);
                ifaceActivePill.textContent = isActive ? "active" : "inactive";
              }
              // stats
              const peerCount =
                nd.peer_count ?? (nd.peers ? Object.keys(nd.peers).length : 0);
              const stats = [
                { label: "Network", value: s.network || "-" },
                { label: "relay ip", value: s.ip || "—" },
                { label: "Port", value: s.port || "-" },
                { label: "Peers", value: peerCount },
                { label: "Public IP", value: s.public_ip || "—" },
              ];
              ifaceMeta.innerHTML = stats
                .map(
                  (st) =>
                    `<div class="iface-stat"><span class="label">${st.label}</span><span>${st.value}</span></div>`
                )
                .join("");
              // peers list from new_data
              let peersData = nd.peers || {};
              if (typeof peersData === "string") {
                try {
                  const parsed = JSON.parse(peersData);
                  peersData = parsed?.peers || parsed || {};
                } catch {
                  peersData = {};
                }
              }
              const names = Object.keys(peersData);
              peers = names.map((n) => {
                const info = peersData[n] || {};
                return {
                  public_key: info.public_key || n,
                  name: n,
                  active: !!info.active,
                  last_handshake: info.last_handshake || null,
                  last_handshake_str: info.last_handshake_str || "",
                  download: info.download || "0 KiB",
                  uploaded: info.uploaded || "0 KiB",
                };
              });
              renderPeerList();
              // Keep island expanded (no peer open) after server update
              islandEl.classList.add("expanded");
              islandEl
                .querySelector(".details-region")
                ?.classList.remove("peer-open");
              hidePeerDetailPanel();
              emptyState.style.display = "block";
              // Determine if backend reports an actual change
              const changed = !!updPayload?.something_changed;
              const applyBtn = form.querySelector("#eimValidate");
              if (changed) {
                // Close modal then show success + guidance
                close();
                showToast("Server updated");
                const finalPort =
                  currentServer?.port || s.port || updPayload?.port;
                showInterfaceSuccess("edited", currentInterface, finalPort);
              } else {
                // Keep modal open; inform user nothing changed and reflect via button label
                showToast("No changes detected");
                feedback.style.color = "#a0b4c0";
                feedback.textContent = "No changes to apply.";
                if (applyBtn) {
                  const originalText = applyBtn.textContent;
                  applyBtn.textContent = "Nothing changed";
                  applyBtn.disabled = true;
                  // Revert after short delay so user can attempt edits
                  setTimeout(() => {
                    if (!document.body.contains(applyBtn)) return;
                    applyBtn.textContent = originalText;
                    applyBtn.disabled = false;
                  }, 2000);
                }
              }
            } catch (err) {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = `Update failed: ${
                err?.message || "error"
              }`;
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err?.message || "validation failed"
            }`;
          }
        });
      }
      if (btnServerSettings) btnServerSettings.onclick = openEditInterfaceModal;
      if (btnCancelEdit)
        btnCancelEdit.onclick = () => {
          if (originalPeerData) openPeer(currentPeerPublicKey);
        };
      // Add Interface modal
      function buildAddInterfaceModal(prefill, loading = false) {
        const name = prefill?.name || "";
        const port = prefill?.port ?? "";
        const network = prefill?.network || "";
        const public_ip = prefill?.public_ip || "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        const chkDis = loading ? "disabled" : "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="aimClose" aria-label="Close">×</button>\n    <h3>Add Interface</h3>\n    <form id="aimForm" data-loading="${
          loading ? 1 : 0
        }" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="aimName">Name</label>\n        <input ${dis} class="${cls.trim()}" id="aimName" name="name" value="${name}" placeholder="e.g. wg0" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimPort">Port</label>\n        <input ${dis} class="${cls.trim()}" id="aimPort" name="port" value="${port}" placeholder="51820"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimNetwork">Network</label>\n        <input ${dis} class="${cls.trim()}" id="aimNetwork" name="network" value="${network}" placeholder="10.0.0.0/24"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimPublicIP">Public IP</label>\n        <input ${dis} class="${cls.trim()}" id="aimPublicIP" name="public_ip" value="${public_ip}" placeholder="e.g. 203.0.113.10"/>\n      </div>\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <input type="checkbox" id="aimIgnore" ${chkDis} checked />\n        <label for="aimIgnore" style="margin:0;">Ignore network range check</label>\n      </div>\n      <div id="aimFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="aimCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="aimCreate" class="btn-glow">Create</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function openAddInterfaceModal() {
        if (!addInterfaceModalMount) return;
        // Render instantly in loading state
        addInterfaceModalMount.innerHTML = buildAddInterfaceModal({}, true);
        addInterfaceModalMount.style.display = "block";
        const overlay = addInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = addInterfaceModalMount.querySelector("#aimClose");
        const btnCancel = addInterfaceModalMount.querySelector("#aimCancel");
        const form = addInterfaceModalMount.querySelector("#aimForm");
        const feedback = addInterfaceModalMount.querySelector("#aimFeedback");
        const nameInput = addInterfaceModalMount.querySelector("#aimName");
        function close() {
          addInterfaceModalMount.style.display = "none";
          addInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        let isLoading = true;
        // Kick off async fetch of defaults; populate and unlock when ready
        (async () => {
          let defaults = {};
          try {
            defaults =
              (await fetchJSON(`${apiBase}/interfaces/defaults`, {
                headers: headers(),
              })) || {};
          } catch (_) {
            defaults = {};
          }
          // Update values
          const _name = addInterfaceModalMount.querySelector("#aimName");
          const _port = addInterfaceModalMount.querySelector("#aimPort");
          const _net = addInterfaceModalMount.querySelector("#aimNetwork");
          const _pip = addInterfaceModalMount.querySelector("#aimPublicIP");
          if (_name && !_name.value) _name.value = defaults.name || "";
          if (_port && !_port.value) _port.value = defaults.port ?? "";
          if (_net && !_net.value) _net.value = defaults.network || "";
          if (_pip && !_pip.value) _pip.value = defaults.public_ip || "";
          // Unlock inputs
          [_name, _port, _net, _pip].forEach((el) => {
            if (el) {
              el.removeAttribute("disabled");
              el.classList.remove("input-loading");
              el.removeAttribute("aria-busy");
            }
          });
          const chk = addInterfaceModalMount.querySelector("#aimIgnore");
          if (chk) chk.removeAttribute("disabled");
          isLoading = false;
          form?.setAttribute("data-loading", "0");
          // Now focus the name field
          _name?.focus();
        })();
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (form?.getAttribute("data-loading") === "1") {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Please wait for defaults...";
            return;
          }
          const name = (
            addInterfaceModalMount.querySelector("#aimName")?.value || ""
          ).trim();
          const portStr = (
            addInterfaceModalMount.querySelector("#aimPort")?.value || ""
          ).trim();
          const network = (
            addInterfaceModalMount.querySelector("#aimNetwork")?.value || ""
          ).trim();
          const public_ip = (
            addInterfaceModalMount.querySelector("#aimPublicIP")?.value || ""
          ).trim();
          const ignore =
            !!addInterfaceModalMount.querySelector("#aimIgnore")?.checked;
          const port = parseInt(portStr, 10);
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name is required";
            return;
          }
          if (!Number.isFinite(port)) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Port is required";
            return;
          }
          if (!network) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Network is required";
            return;
          }
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          try {
            const validateBody = {
              interface: name,
              port,
              network,
              ignore_range_check: ignore,
            };
            const v = await fetchJSON(`${apiBase}/interfaces/validate`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(validateBody),
            });
            if (!v || !v.ok) {
              throw new Error(v?.detail || "Validation failed");
            }
            feedback.style.color = "#32c861";
            feedback.textContent = "Validated. Creating...";
            const createBody = { interface: name, port, network };
            if (public_ip) createBody.public_ip = public_ip;
            const res = await fetchJSON(`${apiBase}/interfaces/add`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(createBody),
            });
            // Update interface list from returned data
            const list = Array.isArray(res?.interfaces) ? res.interfaces : [];
            if (list.length) {
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            close();
            showToast("Interface created");
            // Select the newly created interface
            await selectInterface(name);
            // After selection, display guidance modal
            showInterfaceSuccess("created", name, port);
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Creation failed"}`;
          }
        });
      }
      if (btnOpenAddInterface)
        btnOpenAddInterface.addEventListener("click", openAddInterfaceModal);
      // QR + Edit peer actions
      function showQrModal(peerName) {
        if (!currentInterface || !peerName) {
          showToast("No peer selected", false);
          return;
        }
        qrPeerModalMount.innerHTML = `<div class="peer-modal-overlay"><div class="peer-modal" style="width:460px;" role="dialog" aria-modal="true"><button class="peer-modal-close" id="qrClose">×</button><h3 style="margin-top:0;">QR Code - ${peerName}</h3><div id="qrContent" style="display:flex;justify-content:center;align-items:center;min-height:240px;">Loading...</div><div class="pm-actions" style="justify-content:flex-end;"><button class="btn-danger" type="button" id="qrDismiss">Close</button></div></div></div>`;
        qrPeerModalMount.style.display = "block";
        const overlay = qrPeerModalMount.querySelector(".peer-modal-overlay");
        const closeBtn = qrPeerModalMount.querySelector("#qrClose");
        const dismiss = qrPeerModalMount.querySelector("#qrDismiss");
        const content = qrPeerModalMount.querySelector("#qrContent");
        function close() {
          qrPeerModalMount.style.display = "none";
          qrPeerModalMount.innerHTML = "";
        }
        closeBtn.onclick = close;
        dismiss.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        fetchJSON(
          `${apiBase}/interfaces/${encodeURIComponent(
            currentInterface
          )}/peers/${encodeURIComponent(peerName)}/qr`,
          { headers: headers() }
        )
          .then((d) => {
            if (!d || !d.qr_png_base64) {
              content.textContent = "Failed fetching QR";
              return;
            }
            // Display QR at roughly 2x size (while preserving crisp modules)
            content.innerHTML = `<img alt="QR for ${peerName}" style="image-rendering:pixelated;border:1px solid #22323f;padding:12px;background:#0f181f;border-radius:16px;max-width:none;width:360px;height:360px;" src="data:image/png;base64,${d.qr_png_base64}">`;
          })
          .catch(() => {
            content.textContent = "Failed fetching QR";
          });
      }
      if (btnQrPeer)
        btnQrPeer.addEventListener("click", () => {
          const name = peerDetailTitle.textContent.trim();
          if (!name || name === "Peer") {
            showToast("Select a peer first", false);
            return;
          }
          showQrModal(name);
        });
      // Edit Peer modal
      function buildEditPeerModal(prefill, loading = false) {
        const n = prefill?.name || "";
        const ip = prefill?.ip || "";
        const allowed = prefill?.allowed_ips || "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="epmClose" aria-label="Close">×</button>\n    <h3>Edit Peer</h3>\n    <form id="epmForm" data-loading="${
          loading ? 1 : 0
        }" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="epmName">Peer Name</label>\n        <input ${dis} class="${cls.trim()}" id="epmName" name="name" value="${n}" placeholder="peer name" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="epmIP">Peer IP</label>\n        <input ${dis} class="${cls.trim()}" id="epmIP" name="ip" value="${ip}" placeholder="e.g. 10.0.0.2/32"/>\n      </div>\n      <div class="pm-field">\n        <label for="epmAllowed">Allowed IPs</label>\n        <input ${dis} class="${cls.trim()}" id="epmAllowed" name="allowed_ips" value="${allowed}" placeholder="e.g. 0.0.0.0/0, ::/0"/>\n      </div>\n      <div id="epmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="epmCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="epmApply" class="btn-glow">Apply</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function openEditPeerModal() {
        if (!currentInterface || !currentPeerName) {
          showToast("Select a peer first", false);
          return;
        }
        // Open instantly in loading state
        editPeerModalMount.innerHTML = buildEditPeerModal({}, true);
        editPeerModalMount.style.display = "block";
        const overlay = editPeerModalMount.querySelector(".peer-modal-overlay");
        const form = editPeerModalMount.querySelector("#epmForm");
        const btnCancel = editPeerModalMount.querySelector("#epmCancel");
        const btnClose = editPeerModalMount.querySelector("#epmClose");
        const feedback = editPeerModalMount.querySelector("#epmFeedback");
        const nameInput = editPeerModalMount.querySelector("#epmName");
        const ipInput = editPeerModalMount.querySelector("#epmIP");
        const allowedInput = editPeerModalMount.querySelector("#epmAllowed");
        function close() {
          editPeerModalMount.style.display = "none";
          editPeerModalMount.innerHTML = "";
        }
        btnCancel.onclick = close;
        btnClose.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        // Populate and unlock asynchronously (use existing detail if available, otherwise fetch)
        (async () => {
          let ip = lastPeerDetail?.peer_data?.ip || "";
          let allowed = lastPeerDetail?.peer_data?.allowed_ips || "";
          if (!ip || !allowed) {
            try {
              const d = await fetchJSON(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/peers/${encodeURIComponent(currentPeerName)}`,
                { headers: headers() }
              );
              ip = d?.peer_data?.ip || ip || "";
              allowed = d?.peer_data?.allowed_ips || allowed || "";
            } catch (_) {}
          }
          // Fill fields
          if (nameInput) nameInput.value = currentPeerName;
          if (ipInput) ipInput.value = ip;
          if (allowedInput) allowedInput.value = allowed;
          // Unlock
          [nameInput, ipInput, allowedInput].forEach((el) => {
            if (el) {
              el.removeAttribute("disabled");
              el.classList.remove("input-loading");
              el.removeAttribute("aria-busy");
            }
          });
          form?.setAttribute("data-loading", "0");
          nameInput?.focus();
        })();
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          const name = nameInput.value.trim();
          const ipVal =
            ipInput.value.trim() || lastPeerDetail?.peer_data?.ip || "";
          const newAllowed = allowedInput.value.trim();
          if (form?.getAttribute("data-loading") === "1") {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Please wait for current values...";
            return;
          }
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name required";
            return;
          }
          const payload = {
            name,
            ip: ipVal || null,
            old_name: currentPeerName,
            old_ip: lastPeerDetail?.peer_data?.ip || null,
            new_allowed: newAllowed || null,
            old_allowed: lastPeerDetail?.peer_data?.allowed_ips || null,
          };
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/validate`,
              {
                method: "POST",
                headers: headers(),
                body: JSON.stringify(payload),
              }
            );
            if (res && res.ok) {
              feedback.style.color = "#32c861";
              feedback.textContent = "Validated. Applying changes...";
              // Build patch body based on differences
              const patchBody = {};
              if (
                newAllowed &&
                newAllowed !== (lastPeerDetail?.peer_data?.allowed_ips || "")
              )
                patchBody.allowed_ips = newAllowed;
              if (ipVal && ipVal !== (lastPeerDetail?.peer_data?.ip || ""))
                patchBody.ip = ipVal;
              if (name && name !== currentPeerName) patchBody.new_name = name;
              if (Object.keys(patchBody).length === 0) {
                feedback.textContent = "Nothing to change";
                return;
              }
              const upd = await fetchJSON(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/peers/${encodeURIComponent(currentPeerName)}/update`,
                {
                  method: "POST",
                  headers: headers(),
                  body: JSON.stringify(patchBody),
                }
              );
              // Update peers list from returned interface summary
              const iface = upd?.interface || {};
              let peersData = iface.peers || {};
              if (typeof peersData === "string") {
                try {
                  const parsed = JSON.parse(peersData);
                  peersData = parsed?.peers || parsed || {};
                } catch {
                  peersData = {};
                }
              }
              const names = Object.keys(peersData);
              peers = names.map((n) => {
                const info = peersData[n] || {};
                return {
                  public_key: info.public_key || n,
                  name: n,
                  active: !!info.active,
                  last_handshake: info.last_handshake || null,
                  last_handshake_str: info.last_handshake_str || "",
                  download: info.download || "0 KiB",
                  uploaded: info.uploaded || "0 KiB",
                };
              });
              renderPeerList();
              // Select corrected/renamed peer and populate detail
              const finalName = upd?.name || name;
              const selected = peers.find((p) => p.name === finalName);
              close();
              showToast("Peer updated");
              if (selected) {
                openPeer(selected.public_key || selected.name);
              }
            } else {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = (res && res.detail) || "Validation failed";
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err.message || "Validation error"
            }`;
          }
        });
      }
      if (btnEditPeer) btnEditPeer.addEventListener("click", openEditPeerModal);
      btnRefresh.onclick = async () => {
        await loadInterfaceAll();
        showToast("Refreshed");
      };
      peerSearch.addEventListener("input", renderPeerList);
      (async () => {
        await loadInterfaces(); /* No auto-select; user must click an interface to expand */
        // Start periodic refresh of interface list every 5s
        clearInterfacesListInterval();
        interfacesListInterval = setInterval(() => {
          try {
            loadInterfaces();
          } catch (_) {}
        }, 5000);
      })();
      // Clicking the top-left PyGuard logo/title resets selection to initial state
      function resetToInitialState() {
        clearPeerDetailInterval();
        clearInterfaceRefreshInterval();
        // Remove any active states
        document
          .querySelectorAll(".peer-row.active")
          .forEach((el) => el.classList.remove("active"));
        document
          .querySelectorAll(".iface-item")
          .forEach((el) => el.classList.remove("active"));
        const detailsRegion = islandEl.querySelector(".details-region");
        if (detailsRegion) detailsRegion.classList.remove("peer-open");
        islandEl.classList.remove("peer-open");
        islandEl.classList.remove("expanded");
        hidePeerDetailPanel();
        // Clear UI texts
        const ifaceTitleEl = document.getElementById("ifaceTitle");
        const ifaceMetaEl = document.getElementById("ifaceStats");
        const peersContainerEl = document.getElementById("peersContainer");
        if (ifaceTitleEl) ifaceTitleEl.textContent = "Select an interface";
        if (ifaceMetaEl) ifaceMetaEl.innerHTML = "";
        if (peersContainerEl) peersContainerEl.innerHTML = "";
        const pill = document.getElementById("ifaceActivePill");
        if (pill) pill.style.display = "none";
        const currentLabel = document.getElementById("current-interface-label");
        if (currentLabel) currentLabel.textContent = "";
        // Reset state
        currentPeerPublicKey = null;
        currentPeerName = null;
        lastPeerDetail = null;
        currentInterface = null;
        // Ensure empty state message is visible in peers panel
        const emptyStateEl = document.getElementById("emptyState");
        if (emptyStateEl) emptyStateEl.style.display = "block";
      }
      if (logoTitle) {
        logoTitle.style.cursor = "pointer";
        logoTitle.addEventListener("click", resetToInitialState);
      }
      // Logout confirmation (styled modal)
      const logoutLink = document.querySelector(".logout");
      const logoutModalMount = document.getElementById("logoutModal");
      function buildLogoutModal() {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="lomClose" aria-label="Close">×</button>\n    <h3>Logout</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to log out?</div>\n    <div class="pm-actions">\n      <button type="button" id="lomCancel" class="btn-press">Cancel</button>\n      <button type="button" id="lomLogout" class="btn-danger btn-press">Logout</button>\n    </div>\n  </div>\n</div>`;
      }
      function openLogoutModal(anchor) {
        logoutModalMount.innerHTML = buildLogoutModal();
        logoutModalMount.style.display = "block";
        const overlay = logoutModalMount.querySelector(".peer-modal-overlay");
        const btnClose = logoutModalMount.querySelector("#lomClose");
        const btnCancel = logoutModalMount.querySelector("#lomCancel");
        const btnLogout = logoutModalMount.querySelector("#lomLogout");
        function close() {
          logoutModalMount.style.display = "none";
          logoutModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnLogout.onclick = async () => {
          await fetch("/logout", { method: "POST" }).then(() => {
            window.location.href = "/login";
          });
        };
      }
      if (logoutLink) {
        logoutLink.addEventListener("click", (e) => {
          e.preventDefault();
          openLogoutModal(logoutLink);
        });
      }

      // Reusable Interface Success / Guidance Modal
      const interfaceSuccessMount = document.getElementById(
        "interfaceSuccessModal"
      );
      const settingsModalMount = document.getElementById("settingsModal");
      const btnOpenSettings = document.getElementById("btnOpenSettings");
      function buildSettingsModal(activeCat = "password") {
        return `\n<div class=\"peer-modal-overlay\">\n  <div class=\"settings-modal\" role=\"dialog\" aria-modal=\"true\">\n    <button class=\"settings-close-btn\" id=\"settingsClose\" aria-label=\"Close\">×</button>\n    <div class=\"settings-left\">\n      <h4>Settings</h4>\n      <ul class=\"settings-nav\">\n        <li data-cat=\"password\" class=\"${
          activeCat === "password" ? "active" : ""
        }\">Change Password</li>\n      </ul>\n    </div>\n    <div class=\"settings-content\" id=\"settingsContent\">\n      ${renderSettingContent(
          activeCat
        )}\n    </div>\n  </div>\n</div>`;
      }
      function renderSettingContent(cat) {
        if (cat === "password") {
          return `<div id=\"passwordSetting\">\n  <h3>Change Password</h3>\n  <p style=\"margin:0;font-size:13px;color:#90a4ae;line-height:1.5;\">Update the administrative password. After changing, sessions may require re-authentication.</p>\n  <form id=\"cpForm\" class=\"settings-form\" autocomplete=\"off\">\n    <div class=\"settings-field\">\n      <label for=\"cpOld\">Current Password</label>\n      <input id=\"cpOld\" name=\"old_password\" type=\"password\" required autocomplete=\"current-password\" />\n    </div>\n    <div class=\"settings-field\">\n      <label for=\"cpNew1\">New Password</label>\n      <input id=\"cpNew1\" name=\"new_password1\" type=\"password\" required autocomplete=\"new-password\" />\n    </div>\n    <div class=\"settings-field\">\n      <label for=\"cpNew2\">Confirm New Password</label>\n      <input id=\"cpNew2\" name=\"new_password2\" type=\"password\" required autocomplete=\"new-password\" />\n    </div>\n    <div id=\"cpFeedback\"></div>\n    <div style=\"display:flex; gap:12px; justify-content:flex-end;\">\n      <button type=\"button\" id=\"cpCancel\" class=\"btn-danger btn-press\">Cancel</button>\n      <button type=\"submit\" id=\"cpSubmit\" class=\"btn-glow\">Change</button>\n    </div>\n  </form>\n</div>`;
        }
        return `<div><h3>Unknown</h3><p style=\"font-size:13px;color:#90a4ae;\">Category not found.</p></div>`;
      }
      function openSettingsModal(cat = "password") {
        if (!settingsModalMount) return;
        settingsModalMount.innerHTML = buildSettingsModal(cat);
        settingsModalMount.style.display = "block";
        const overlay = settingsModalMount.querySelector(".peer-modal-overlay");
        const closeBtn = settingsModalMount.querySelector("#settingsClose");
        const navItems =
          settingsModalMount.querySelectorAll(".settings-nav li");
        const content = settingsModalMount.querySelector("#settingsContent");
        function close() {
          settingsModalMount.style.display = "none";
          settingsModalMount.innerHTML = "";
        }
        closeBtn.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        navItems.forEach((li) =>
          li.addEventListener("click", () => {
            navItems.forEach((n) => n.classList.remove("active"));
            li.classList.add("active");
            const c = li.getAttribute("data-cat");
            content.innerHTML = renderSettingContent(c);
            wirePasswordForm();
          })
        );
        wirePasswordForm();
      }
      function wirePasswordForm() {
        const form = settingsModalMount.querySelector("#cpForm");
        if (!form) return;
        const oldEl = form.querySelector("#cpOld");
        const n1El = form.querySelector("#cpNew1");
        const n2El = form.querySelector("#cpNew2");
        const feedback = form.querySelector("#cpFeedback");
        const cancelBtn = form.querySelector("#cpCancel");
        const submitBtn = form.querySelector("#cpSubmit");
        function setFeedback(msg, ok = true) {
          if (feedback) {
            feedback.style.color = ok ? "#9cf0b7" : "#ff6b6b";
            feedback.textContent = msg;
          }
        }
        cancelBtn.onclick = () => {
          settingsModalMount.style.display = "none";
          settingsModalMount.innerHTML = "";
        };
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (!oldEl.value) {
            setFeedback("Current password required", false);
            return;
          }
          if (!n1El.value || !n2El.value) {
            setFeedback("New password fields required", false);
            return;
          }
          if (n1El.value !== n2El.value) {
            setFeedback("New passwords do not match", false);
            return;
          }
          if (n1El.value.length < 1) {
            setFeedback("Password too short", false);
            return;
          }
          setFeedback("Changing...", true);
          submitBtn.disabled = true;
          const orig = submitBtn.textContent;
          submitBtn.textContent = "Working...";
          try {
            const res = await fetch(`${apiBase}/change-password`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify({
                old_password: oldEl.value,
                new_password: n1El.value,
              }),
            });
            let data = {};
            try {
              data = await res.json();
            } catch (_) {}
            if (!res.ok) throw new Error(data.detail || res.statusText);
            setFeedback("Password changed successfully");
            showToast("Password changed");
            setTimeout(() => {
              settingsModalMount.style.display = "none";
              settingsModalMount.innerHTML = "";
            }, 1200);
          } catch (err) {
            setFeedback(err.message || "Change failed", false);
            showToast(err.message || "Change failed", false);
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = orig;
          }
        });
      }
      if (btnOpenSettings)
        btnOpenSettings.addEventListener("click", () =>
          openSettingsModal("password")
        );
      function buildInterfaceSuccessModal(kind, iface, port) {
        const heading =
          kind === "edited"
            ? "Interface edited successfully!"
            : kind === "activated"
            ? "Interface activated successfully!"
            : "Interface created successfully!";
        const p = port || "<port>";
        const i = iface || "<iface>";
        const fwCmd1 = `ufw allow ${p}/udp`;
        const fwCmd2 = `ufw route allow in on ${i} out on ${i}`;
        const id1 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`;
        const id2 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`;
        const id3 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`; // sysctl block
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" style="max-width:640px;" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="ismClose" aria-label="Close">×</button>\n    <h3 style="margin-top:0;">${heading}</h3>\n    <div style="font-size:13px;color:#cfd8dc;display:flex;flex-direction:column;gap:14px;line-height:1.45;">\n      <div>Interface <b>${i}</b> on port <b>${p}</b> is ready. To ensure full connectivity and proper WireGuard operation, review the recommended system steps below.</div>\n      <ol style="margin:0 0 0 18px;padding:0;display:flex;flex-direction:column;gap:14px;">\n        <li>To allow for WireGuard traffic port <b>${p}</b> must be open and publicly reachable end-to-end (host firewall, upstream router/NAT, cloud security group):<div class="pg-code-block pg-copy-wrap"><button class="pg-copy-btn" data-target="${id1}">Copy</button><code id="${id1}">${fwCmd1}</code></div>For peer-to-peer routing between clients:<div class="pg-code-block pg-copy-wrap"><button class="pg-copy-btn" data-target="${id2}">Copy</button><code id="${id2}">${fwCmd2}</code></div><div style="margin-top:6px;font-size:11px;color:#90a4ae;">These commands plus external firewall/NAT rules ensure peers can reach the interface.</div></li>\n        <li>Enable packet forwarding system-wide:<div class="pg-code-block pg-copy-wrap"><button class="pg-copy-btn" data-target="${id3}">Copy</button><code id="${id3}">sysctl -w net.ipv4.ip_forward=1\n# (optional IPv6)\nsysctl -w net.ipv6.conf.all.forwarding=1</code></div><span style="display:block;margin-top:4px;">Persist in /etc/sysctl.conf for reboot survival.</span></li>\n      </ol>\n    </div>\n    <div class="pm-actions" style="margin-top:18px;justify-content:flex-end;gap:10px;">\n      <button type="button" id="ismApplyRules" class="btn-glow pg-fixed-btn" style="background:#1f3a4d;">Apply Rules</button>\n      <button type="button" id="ismUnderstand" class="btn-glow">I Understand</button>\n    </div>\n  </div>\n</div>`;
      }
      function showInterfaceSuccess(kind, iface, port) {
        if (!interfaceSuccessMount) return;
        interfaceSuccessMount.innerHTML = buildInterfaceSuccessModal(
          kind,
          iface,
          port
        );
        interfaceSuccessMount.style.display = "block";
        const overlay = interfaceSuccessMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = interfaceSuccessMount.querySelector("#ismClose");
        const btnOk = interfaceSuccessMount.querySelector("#ismUnderstand");
        const btnApply = interfaceSuccessMount.querySelector("#ismApplyRules");
        if (btnApply) {
          const applyIface = iface;
          const applyPort = port;
          btnApply.addEventListener("click", async () => {
            if (!applyPort || !applyIface) {
              showToast("Missing interface or port", false);
              return;
            }
            if (btnApply.getAttribute("data-busy") === "1") return;
            const orig = btnApply.textContent;
            btnApply.setAttribute("data-busy", "1");
            btnApply.textContent = "Applying...";
            btnApply.disabled = true;
            try {
              await fetchJSON(
                `${apiBase}/shell/port/${encodeURIComponent(applyPort)}`,
                { method: "POST", headers: headers() }
              );
              await fetchJSON(
                `${apiBase}/shell/route/${encodeURIComponent(applyIface)}`,
                { method: "POST", headers: headers() }
              );
              btnApply.textContent = "Applied";
              showToast("Rules applied");
              setTimeout(() => {
                btnApply.textContent = orig;
                btnApply.disabled = false;
                btnApply.removeAttribute("data-busy");
              }, 2200);
            } catch (e) {
              btnApply.textContent = "Failed";
              showToast(e.message || "Apply failed", false);
              setTimeout(() => {
                btnApply.textContent = orig;
                btnApply.disabled = false;
                btnApply.removeAttribute("data-busy");
              }, 2500);
            }
          });
        }
        // Copy button handler (event delegation for this modal instance)
        interfaceSuccessMount
          .querySelectorAll(".pg-copy-btn")
          .forEach((btn) => {
            btn.addEventListener("click", (e) => {
              e.stopPropagation();
              const targetId = btn.getAttribute("data-target");
              const codeEl = targetId
                ? interfaceSuccessMount.querySelector(
                    `#${CSS.escape(targetId)}`
                  )
                : null;
              const text = codeEl ? codeEl.innerText : "";
              if (!text) return;
              const copyText = async (t) => {
                try {
                  if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(t);
                  } else {
                    const ta = document.createElement("textarea");
                    ta.value = t;
                    ta.style.position = "fixed";
                    ta.style.top = "-2000px";
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand("copy");
                    ta.remove();
                  }
                  btn.classList.add("copied");
                  const original = btn.textContent;
                  btn.textContent = "Copied";
                  setTimeout(() => {
                    btn.textContent = original;
                    btn.classList.remove("copied");
                  }, 1500);
                } catch (_) {
                  const original = btn.textContent;
                  btn.textContent = "Failed";
                  setTimeout(() => {
                    btn.textContent = original;
                  }, 1500);
                }
              };
              copyText(text);
            });
          });
        function close() {
          interfaceSuccessMount.style.display = "none";
          interfaceSuccessMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnOk.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
      }
    </script>
  </body>
</html>
