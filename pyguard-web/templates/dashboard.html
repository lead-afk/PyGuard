<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>PyGuard Dashboard</title>
    <link rel="stylesheet" href="/static/style.css" />
    <style>
      body,
      html {
        height: 100%;
        background-image: url("/static/img/background.jpg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        overflow: hidden;
      }
      .top-bar {
        max-width: 1750px;
        margin: 14px auto 0;
        border-radius: 18px;
        padding: 10px 30px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        border: 1px solid #1f2c38;
        box-shadow: 0 4px 16px -6px rgba(0, 0, 0, 0.55);
      }
      .top-bar .logo-title img.logo-small {
        width: 42px;
      }
      .top-bar .logo-title h1 {
        font-size: 22px;
      }
      .island-wrapper {
        max-width: 1750px;
        margin: 22px auto 40px;
        padding: 0 18px;
        display: flex;
        justify-content: center;
        min-height: 300px;
      }
      .island {
        position: relative;
        background: #0d141a;
        border: 1px solid #1e2a36;
        border-radius: 26px;
        padding: 34px 46px 46px;
        min-height: 200px;
        max-width: 600px;
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 28px;
        box-shadow: 0 10px 40px -12px rgba(0, 0, 0, 0.65),
          0 0 0 1px #182430 inset;
        transition: all 0.4s ease-out;
        overflow: hidden;
        max-height: 720px;
      }
      #island {
        /* opacity: 0.97; */
        background-color: #182430e3;
        /* backdrop-filter: blur(6px); */
      }
      .island.expanded {
        padding: 28px 30px 40px;
        flex-direction: row;
        align-items: flex-start;
        gap: 34px;
        /* Compact by default (no peer selected) */
        max-width: 1160px;
        min-height: 420px;
        width: 100%;
      }
      /* When a peer is actually open, allow full expansion */
      .island.expanded.peer-open {
        max-width: 1750px;
        min-height: 560px;
      }
      .interfaces-panel {
        width: 100%;
        transition: all 0.4s ease-out;
        position: relative;
        max-height: 660px;
        display: flex;
        flex-direction: column;
      }
      .island.expanded .interfaces-panel {
        width: 270px;
        padding: 26px 20px 32px;
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 26px;
        box-shadow: 0 0 0 1px #16222c inset, 0 8px 28px -14px #000;
        display: flex;
        flex-direction: column;
      }
      .interfaces-panel h3 {
        margin: 0 0 14px;
        font-size: 13px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      /* Add spacing under the Add Interface button */
      #btnOpenAddInterface {
        margin-bottom: 14px;
      }
      .iface-list {
        flex: 1;
        overflow-y: auto;
        padding-right: 4px;
        max-height: 800px;
        min-height: 120px;
      }
      .iface-item {
        cursor: pointer;
        padding: 10px 14px;
        font-size: 14px;
        color: #cfd8dc;
        display: flex;
        align-items: center;
        gap: 10px;
        justify-content: space-between;
        margin: 6px 4px 0;
        background: #15202a;
        border: 1px solid #1f2c38;
        border-radius: 10px;
        transition: background 0.25s, border-color 0.25s, transform 0.25s;
      }
      .iface-item:hover {
        background: #1d2c38;
      }
      .iface-item.active {
        background: #27455e;
        color: #fff;
        border-color: #335d7a;
      }
      /* removed status-dot in favor of pills */
      .details-region {
        display: none;
        flex-direction: column;
        gap: 22px;
        position: relative;
        flex: 1;
        min-width: 0;
      }
      .island.expanded .details-region {
        display: flex;
        margin-left: 0;
      }
      .details-region.peer-open .peer-detail-panel {
        /* reveal smoothly */
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
        flex-basis: 500px;
        max-width: 500px;
        width: 500px;
      }
      .iface-meta-card {
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 16px;
        padding: 18px 22px 20px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 28px;
        position: relative;
        overflow: hidden;
        min-height: 100px;
        transition: all 0.4s ease-out;
        box-shadow: 0 0 0 1px #16222c inset, 0 8px 28px -14px #000;
      }
      /* remove gray overlay for consistency with other sections */
      .iface-meta-card:before {
        display: none;
      }
      /* add a little more space under the server name */
      .iface-meta-left h2 {
        margin: 0 0 14px;
        font-size: 22px;
        letter-spacing: 0.5px;
      }
      .iface-stats {
        display: flex;
        gap: 18px;
        flex-wrap: wrap;
        font-size: 13px;
        color: #a7bac6;
        margin-top: 20px;
        width: 780px;
      }
      .iface-stat {
        background: #182733;
        padding: 10px 14px;
        border-radius: 12px;
        border: 1px solid #243744;
        display: flex;
        flex-direction: column;
        gap: 4px;
        min-width: 110px;
      }
      .iface-stat span.label {
        text-transform: uppercase;
        font-size: 10px;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      .iface-actions {
        display: flex;
        gap: 10px;
      }
      .iface-actions button {
        padding: 10px 14px;
        font-size: 13px;
        border-radius: 10px;
      }
      .peers-section {
        background: #101d27;
        border: 1px solid #1f2c38;
        border-radius: 22px;
        padding: 20px 24px 26px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        position: relative;
        transition: all 0.4s ease-out;
        min-height: 0; /* allow internal scroll containers */
        box-shadow: 0 0 0 1px #16222c inset, 0 8px 28px -14px #000;
      }
      .peers-layout {
        display: flex;
        gap: 26px;
        align-items: flex-start;
        min-height: 0; /* enable child scroll areas */
      }
      .peers-left {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 16px;
        min-height: 0; /* enable child scroll areas */
        /* smooth width change when peer panel opens */
        transition: flex-basis 0.35s ease, width 0.35s ease;
      }
      .peer-detail-panel {
        background: #15222c;
        border: 1px solid #20313f;
        border-radius: 18px;
        padding: 20px 24px 26px;
        display: flex; /* keep in flow, but collapsed by default */
        flex-direction: column; /* ensure header stacks above fields (fix layout) */
        gap: 16px;
        box-shadow: 0 0 0 1px #1f2c38 inset, 0 8px 26px -12px #000;
        position: relative;
        opacity: 0;
        transform: translateX(20px);
        pointer-events: none;
        max-height: 100%;
        overflow: auto;
        /* fully hidden by default so it does not reserve layout space */
        display: none;
        flex: 0 0 auto;
        width: 0;
        max-width: 0;
        flex-basis: 0;
        /* animate only when shown */
        transition: opacity 0.3s ease, transform 0.35s ease;
      }
      /* When region has peer-open, we show and size the panel */
      .details-region.peer-open .peer-detail-panel {
        display: flex;
        opacity: 1;
        transform: translateX(0);
        pointer-events: auto;
        flex-basis: 500px;
        max-width: 500px;
        width: 500px;
      }
      /* Explicit hidden helper (legacy calls) */
      .peer-detail-panel.hidden {
        display: none !important;
      }
      /* Compact island tweaks: move interface actions above stats and ensure layout fits tighter */
      .island.expanded:not(.peer-open) .iface-meta-card {
        position: relative;
        padding-right: 220px; /* space for actions block */
      }
      .island.expanded:not(.peer-open) .iface-actions {
        position: absolute;
        top: 16px;
        right: 18px;
        z-index: 1;
      }
      .island.expanded:not(.peer-open) .iface-stats {
        margin-top: 20px;
        width: 780px;
      }
      .peer-detail-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      .peer-detail-header h3 {
        margin: 0;
        font-size: 16px;
      }
      .peer-fields {
        display: flex;
        flex-direction: column;
        gap: 10px;
        font-size: 12px;
        /* Ensure consistent right spacing so inputs don't butt against the island edge */
        padding-right: 12px; /* match dual-traffic grid gap */
      }
      .peer-field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .peer-field label {
        text-transform: uppercase;
        font-size: 10px;
        letter-spacing: 1px;
        color: #6fa8dc;
      }
      .peer-field input,
      .peer-field textarea {
        background: #0f181f;
        border: 1px solid #24323d;
        color: #d5e2e9;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        width: 100%;
        resize: vertical;
        font-family: monospace;
        letter-spacing: 0.4px;
        box-sizing: border-box; /* keep consistent right margin within container */
      }
      /* Dual traffic fields (force grid to avoid overlap) */
      .peer-field.dual-traffic {
        display: grid !important;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        align-items: start;
      }
      .peer-field.dual-traffic .traffic-col {
        min-width: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .peer-field.dual-traffic input {
        width: 100%;
        box-sizing: border-box;
      }
      #detailPublicKey {
        font-size: 11px;
      }
      .peer-field input[readonly],
      .peer-field textarea[readonly] {
        opacity: 0.85;
      }
      .download-btn {
        background: #1f3a4d;
        border: 1px solid #31566f;
        color: #d9e6ed;
        padding: 8px 14px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 12px;
      }
      .download-btn:hover {
        background: #274a63;
      }
      .cog-btn {
        background: #1f3a4d;
        border: 1px solid #31566f;
        color: #d9e6ed;
        padding: 10px 14px;
        border-radius: 10px;
        cursor: pointer;
        font-size: 13px;
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .cog-btn:hover {
        background: #274a63;
      }
      .status-pill {
        display: inline-block;
        margin-left: 8px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.6px;
        border: 1px solid transparent;
        vertical-align: middle;
      }
      .status-pill.ok {
        background: #113820;
        color: #9cf0b7;
        border-color: #2e6b41;
        box-shadow: 0 0 8px -2px rgba(156, 240, 183, 0.4);
      }
      .status-pill.bad {
        background: #3a1b1b;
        color: #ffb3b3;
        border-color: #6b2e2e;
        box-shadow: 0 0 8px -2px rgba(255, 179, 179, 0.3);
      }
      .status-pill.ok:hover {
        box-shadow: 0 0 12px -1px rgba(156, 240, 183, 0.6);
      }
      .status-pill.bad:hover {
        box-shadow: 0 0 12px -1px rgba(255, 179, 179, 0.5);
      }
      .status-pill.small {
        font-size: 10px;
        padding: 1px 6px;
      }
      /* Pill hover animations and glows */
      .status-pill {
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        cursor: help;
      }
      .status-pill:hover {
        transform: translateY(-2px);
      }
      /* Feature pills (DNS, Docker forward, VPN gateway) */
      .status-pill.feature {
        background: #1a2530;
        color: #90a4ae;
        border-color: #2a3a48;
        opacity: 0.9;
      }
      .status-pill.feature.off {
        background: #1a2530;
        color: #7f95a1;
        border-color: #2a3a48;
        opacity: 0.85;
      }
      .status-pill.feature.on.pill-dns {
        /* lime/green */
        background: #113820;
        color: #9cf0b7;
        border-color: #2e6b41;
        box-shadow: 0 0 8px -2px rgba(156, 240, 183, 0.4);
      }
      .status-pill.feature.on.pill-docker {
        /* light blue */
        background: #143642;
        color: #7fd7ff;
        border-color: #1e5568;
        box-shadow: 0 0 8px -2px rgba(127, 215, 255, 0.4);
      }
      .status-pill.feature.on.pill-gateway {
        /* purple */
        background: #2a1740;
        color: #d6b3ff;
        border-color: #4b2a6b;
        box-shadow: 0 0 8px -2px rgba(214, 179, 255, 0.4);
      }
      /* Enhanced hover effects for active pills */
      .status-pill.feature.on:hover {
        transform: translateY(-3px);
      }
      .status-pill.feature.on.pill-dns:hover {
        box-shadow: 0 0 12px -1px rgba(156, 240, 183, 0.6);
      }
      .status-pill.feature.on.pill-docker:hover {
        box-shadow: 0 0 12px -1px rgba(127, 215, 255, 0.6);
      }
      .status-pill.feature.on.pill-gateway:hover {
        box-shadow: 0 0 12px -1px rgba(214, 179, 255, 0.6);
      }
      .peers-section-header {
        display: flex;
        align-items: center;
        /* Use natural flow; right controls will push via auto margin */
      }
      .peers-section-header .peer-tools {
        margin-left: auto;
        display: flex;
        align-items: center;
        gap: 10px;
        padding-right: 2px; /* subtle right breathing room */
      }
      .peers-section-header h3 {
        margin: 0;
        font-size: 16px;
      }
      .peer-search {
        background: #162633;
        border: 1px solid #223444;
        color: #d5e2e9;
        padding: 10px 14px;
        border-radius: 10px;
        font-size: 14px;
        width: 220px;
      }
      .peer-list {
        display: grid;
        gap: 12px;
        grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
        min-width: 590px;
        overflow-y: auto; /* scroll when many peers */
        max-height: 420px;
        padding-right: 6px; /* keep scrollbar off content */
      }
      .peer-row {
        padding: 12px 14px 14px;
        cursor: pointer;
        font-size: 13px;
        color: #cfd8dc;
        display: flex;
        flex-direction: column;
        gap: 6px;
        background: #15202a;
        border: 1px solid #1f2c38;
        border-radius: 14px;
        transition: background 0.25s, border-color 0.25s;
        position: relative;
      }
      .peer-row:hover {
        background: #1d2c38;
      }
      .peer-row.active {
        background: #27455e;
        border-color: #335d7a;
      }
      .peer-row .line1 {
        display: flex;
        justify-content: space-between;
        font-weight: 500;
      }
      .peer-row .line2 {
        font-size: 11px;
        color: #90a4ae;
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .empty-state {
        font-size: 13px;
        color: #7f95a1;
        padding: 10px 4px;
      }
      #peerEditor {
        display: none !important;
      }
      /* Add Peer modal */
      .peer-add-btn {
        width: 38px;
        height: 38px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        font-weight: 600;
        padding: 0;
        border-radius: 12px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #d8e4ec;
      }
      .peer-add-btn:hover {
        background: #243643;
      }
      .peer-modal-overlay {
        position: fixed;
        inset: 0;
        backdrop-filter: blur(6px);
        background: rgba(10, 15, 20, 0.72);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 900;
        min-height: 100vh;
        overflow-y: auto;
      }
      .peer-modal {
        background: #0f181f;
        border: 1px solid #22323f;
        border-radius: 20px;
        padding: 30px 34px 32px;
        width: 400px;
        max-width: 92%;
        display: flex;
        flex-direction: column;
        gap: 20px;
        box-shadow: 0 20px 60px -20px #000, 0 0 0 1px #18242e inset;
        margin: auto;
        max-height: 90vh;
        overflow-y: auto;
      }
      .peer-modal h3 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.5px;
      }
      /* Shimmer loading for inputs */
      @keyframes shimmer {
        0% {
          background-position: 200% 0;
        }
        100% {
          background-position: -200% 0;
        }
      }
      .input-loading {
        color: transparent !important;
        background-image: linear-gradient(
          90deg,
          #132028 25%,
          #1b2b36 50%,
          #132028 75%
        ) !important;
        background-size: 200% 100% !important;
        animation: shimmer 1.2s linear infinite;
      }
      .input-loading::placeholder {
        color: transparent !important;
      }
      .pm-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .pm-field label {
        font-size: 11px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .pm-field input {
        background: #132028;
        border: 1px solid #243541;
        color: #d9e5ec;
        padding: 12px 14px;
        border-radius: 10px;
        font-size: 14px;
      }
      .pm-field input:focus {
        outline: 2px solid #335d7a;
        outline-offset: 1px;
      }
      /* Toggle switch control */
      .switch {
        position: relative;
        display: inline-block;
        width: 44px;
        height: 24px;
        flex-shrink: 0;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
        position: absolute;
      }
      .switch .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: #233645;
        border: 1px solid #2a3a48;
        transition: 0.18s ease;
        border-radius: 999px;
        box-shadow: inset 0 1px 0 0 rgba(0, 0, 0, 0.2);
      }
      .switch .slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 2px;
        top: 1px;
        background: #9fb3bf;
        border-radius: 50%;
        transition: 0.18s ease;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.35);
      }
      .switch input:checked + .slider {
        background: #144727;
        border-color: #1e6b39;
      }
      .switch input:checked + .slider:before {
        transform: translateX(20px);
        background: #9cf0b7;
      }
      .switch input:disabled + .slider {
        opacity: 0.6;
        cursor: not-allowed;
        filter: grayscale(0.2);
      }
      .pm-actions {
        display: flex;
        justify-content: flex-end;
        gap: 14px;
        margin-top: 6px;
      }
      .btn-danger {
        background: linear-gradient(135deg, #4d1b21, #2a0d11);
        border: 1px solid #682b33;
        color: #f2d8da;
        box-shadow: 0 0 0 0 rgba(255, 70, 70, 0.25);
      }
      .btn-danger:hover {
        background: linear-gradient(135deg, #5d2027, #351017);
        box-shadow: 0 0 12px -2px rgba(255, 70, 70, 0.35);
      }
      .btn-danger:active {
        transform: translateY(1px);
      }
      .peer-modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #9fb3bf;
        width: 34px;
        height: 34px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .peer-modal-close:hover {
        background: #27455e;
        color: #fff;
      }
      @media (max-width: 1100px) {
        .island-wrapper {
          min-height: 200px;
        }
        .island.expanded {
          flex-direction: column;
        }
        /* On small screens, compact and expanded peer-open share the same full-width behavior */
        .island.expanded,
        .island.expanded.peer-open {
          max-width: 100%;
          min-height: unset;
        }
        .island.expanded .interfaces-panel {
          width: 100%;
          border-right: none;
          border-top: 1px solid #1f2c38;
          border-radius: 0 0 26px 26px;
          box-shadow: none;
          padding: 20px 18px 26px;
          margin-top: 12px;
        }
        .island.expanded .details-region {
          margin-left: 0;
        }
        .peers-layout {
          flex-direction: column;
        }
        .peer-detail-panel {
          /* on small screens, slide down and occupy full width when open */
          transform: translateY(20px);
          max-height: none;
        }
        .details-region.peer-open .peer-detail-panel {
          flex-basis: 100%;
          max-width: 100%;
          width: 100%;
        }
        /* Reset absolute actions on mobile to avoid overlap */
        .island.expanded:not(.peer-open) .iface-meta-card {
          padding-right: 22px;
        }
        .island.expanded:not(.peer-open) .iface-actions {
          position: static;
          margin-left: auto;
        }
        .peer-list {
          grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        }
      }
      /* Status bar (toast) */
      .toast {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        min-width: -moz-available; /* Firefox available width */
        /* optional fallbacks */
        width: -webkit-fill-available;
        max-width: 100%;
        margin: 0 auto;
        z-index: 1000;
        text-align: center;
        color: #e9f0f6;
        border-top: 1px solid #1f2c38;
        backdrop-filter: blur(4px);
        border-radius: 10px 10px 0 0;
        box-shadow: 0 -8px 26px -16px rgba(0, 0, 0, 0.6);
        opacity: 0;
        transform: translateY(8px);
        pointer-events: none;
        transition: opacity 0.25s ease, transform 0.25s ease;
      }
      .toast.show {
        opacity: 1;
        transform: translateY(0);
        pointer-events: auto;
      }
      /* Settings modal styles */
      .settings-modal {
        background: #0f181f;
        border: 1px solid #22323f;
        border-radius: 22px;
        width: 720px;
        max-width: 95%;
        display: flex;
        flex-direction: row;
        gap: 0;
        min-height: 420px;
        max-height: 85vh;
        overflow: hidden;
        position: relative;
        box-shadow: 0 18px 48px -20px #000, 0 0 0 1px #18242e inset;
      }
      .settings-left {
        width: 200px;
        background: #101d27;
        border-right: 1px solid #1f2c38;
        display: flex;
        flex-direction: column;
        padding: 24px 0 8px;
        gap: 4px;
      }
      .settings-left h4 {
        margin: 0 18px 10px;
        font-size: 12px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .settings-nav {
        list-style: none;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .settings-nav li {
        cursor: pointer;
        padding: 10px 18px;
        font-size: 13px;
        color: #cfd8dc;
        border-left: 3px solid transparent;
        transition: background 0.25s, border-color 0.25s;
      }
      .settings-nav li:hover {
        background: #162633;
      }
      .settings-nav li.active {
        background: #1d2c38;
        border-color: #335d7a;
        color: #fff;
      }
      .settings-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        padding: 30px 34px 34px;
        overflow-y: auto;
        gap: 24px;
      }
      .settings-content h3 {
        margin: 0;
        font-size: 20px;
        letter-spacing: 0.5px;
      }
      .settings-close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #9fb3bf;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        font-size: 18px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .settings-close-btn:hover {
        background: #27455e;
        color: #fff;
      }
      .settings-form {
        display: flex;
        flex-direction: column;
        gap: 18px;
        max-width: 420px;
      }
      .settings-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .settings-field label {
        font-size: 11px;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #6fa8dc;
      }
      .settings-field input {
        background: #132028;
        border: 1px solid #243541;
        color: #d9e5ec;
        padding: 12px 14px;
        border-radius: 10px;
        font-size: 14px;
      }
      .settings-field input:focus {
        outline: 2px solid #335d7a;
        outline-offset: 1px;
      }
      #cpFeedback {
        font-size: 12px;
        min-height: 18px;
        color: #a0b4c0;
        white-space: pre-wrap;
        word-break: break-word;
      }
      @media (max-width: 760px) {
        .settings-modal {
          flex-direction: column;
          width: 100%;
        }
        .settings-left {
          width: 100%;
          flex-direction: row;
          overflow-x: auto;
          border-right: none;
          border-bottom: 1px solid #1f2c38;
          padding: 14px 10px;
        }
        .settings-nav {
          flex-direction: row;
        }
        .settings-nav li {
          border-left: none;
          border-bottom: 3px solid transparent;
        }
        .settings-nav li.active {
          border-bottom-color: #335d7a;
        }
      }
      /* Copy button styling for interface success modal */
      .pg-copy-wrap {
        position: relative;
      }
      .pg-copy-btn {
        position: absolute;
        top: 4px;
        right: 6px;
        background: #1d2a34;
        border: 1px solid #2a3a48;
        color: #cfd8dc;
        font-size: 11px;
        padding: 3px 8px 4px;
        border-radius: 6px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 4px;
        line-height: 1;
      }
      .pg-copy-btn:hover {
        background: #27455e;
        color: #fff;
      }
      .pg-copy-btn.copied {
        background: #113820;
        border-color: #1e6b39;
        color: #9cf0b7;
      }
      .pg-code-block {
        position: relative;
        margin: 6px 0 4px;
      }
      .pg-code-block code {
        display: block;
        padding: 6px 8px;
        background: #132028;
        border: 1px solid #22323f;
        border-radius: 6px;
        font-size: 12px;
        white-space: pre;
        overflow-x: auto;
      }
      .pg-fixed-btn {
        min-width: 120px;
      }
      .help-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #223543;
        color: #9fd0e6;
        font-size: 12px;
        font-weight: 600;
        cursor: help;
        border: 1px solid #2e4d5f;
        position: relative;
        flex-shrink: 0;
        user-select: none;
        line-height: 1;
      }
      .help-icon:hover {
        background: #2b4a5c;
        color: #d3f2ff;
      }
      .help-tooltip {
        position: fixed;
        z-index: 9999;
        max-width: 320px;
        background: #0f1d25;
        border: 1px solid #2a4554;
        padding: 10px 12px 11px;
        border-radius: 10px;
        font-size: 12px;
        color: #c7d7e0;
        box-shadow: 0 8px 28px -10px rgba(0, 0, 0, 0.6), 0 0 0 1px #16252e inset;
        pointer-events: none;
        opacity: 0;
        transform: translateY(-4px);
        transition: opacity 0.12s ease, transform 0.12s ease;
        line-height: 1.4;
        white-space: normal;
      }
      .help-tooltip.visible {
        opacity: 1;
        transform: translateY(0);
      }
      /* Pulsing glow to draw attention to Enable button when interface inactive */
      @keyframes enablePulse {
        0% {
          box-shadow: 0 0 0 0 rgba(95, 180, 255, 0.55),
            0 0 6px 2px rgba(95, 180, 255, 0.35);
        }
        50% {
          box-shadow: 0 0 0 10px rgba(95, 180, 255, 0),
            0 0 14px 5px rgba(95, 180, 255, 0.7);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(95, 180, 255, 0),
            0 0 4px 1px rgba(95, 180, 255, 0.35);
        }
      }
      .btn-enable-pulse {
        position: relative;
        animation: enablePulse 2.5s ease-in-out infinite;
        background: linear-gradient(135deg, #1d4260, #1c5d7a);
        color: #e1f6ff !important;
        border: 1px solid #2d6f8f !important;
      }
      .btn-enable-pulse:hover {
        background: linear-gradient(135deg, #205072, #217da0);
      }
    </style>
  </head>
  <body>
    <div class="top-bar">
      <div class="logo-title">
        <img
          src="/static/img/logo-transparent.png"
          class="logo-small"
          alt="PyGuard"
        />
        <h1>PyGuard</h1>
      </div>
      <div
        class="top-bar-right"
        style="display: flex; align-items: center; gap: 14px"
      >
        <button
          id="dockerModeBadge"
          type="button"
          style="
            display: none;
            cursor: default;
            background: #143642;
            border: 1px solid #1e5568;
            color: #7fd7ff;
            padding: 6px 14px;
            border-radius: 14px;
            font-size: 12px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            opacity: 0.95;
          "
          aria-disabled="true"
          title="Running inside Docker container"
        >
          Docker Mode
        </button>
        <span
          id="current-interface-label"
          style="font-size: 12px; color: #90a4ae"
        ></span>
        <button id="btnOpenSettings" class="cog-btn" title="Settings">
          Settings
        </button>
        <a class="logout" href="/logout">Logout</a>
      </div>
    </div>
    <div class="island-wrapper">
      <div class="island" id="island">
        <div class="interfaces-panel" id="interfacesPanel">
          <div
            style="
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 8px;
            "
          >
            <h3>Interfaces</h3>
            <button
              id="btnOpenAddInterface"
              class="peer-add-btn btn-pop"
              title="Add Interface"
            >
              +
            </button>
          </div>
          <div class="iface-list" id="interfacesContainer"></div>
        </div>
        <div class="details-region" id="detailsRegion">
          <div
            class="details-col"
            style="
              display: flex;
              flex-direction: column;
              gap: 24px;
              flex: 1;
              min-width: 0;
            "
          >
            <div class="iface-meta-card" id="serverMetaCard">
              <div class="iface-meta-left">
                <div style="display: flex; align-items: center">
                  <h2 id="ifaceTitle" style="margin: 0">Select an interface</h2>
                  <span
                    id="ifaceActivePill"
                    class="status-pill bad"
                    style="display: none"
                    data-help="Interface WireGuard service status. Active means the WireGuard interface is up and running, inactive means it's stopped or not configured to start automatically."
                    >inactive</span
                  >
                  <span
                    id="ifaceDnsPill"
                    class="status-pill small feature off"
                    style="display: none"
                    title="DNS service"
                    data-help="Integrated PyGuard DNS server. When enabled, resolves peer names to their IPs (e.g. peerName.interfaceName -> assigned peer IP) and relay.interfaceName -> first IP in the interface network."
                    >dns</span
                  >
                  <span
                    id="ifaceDockerPill"
                    class="status-pill small feature off pill-docker"
                    style="display: none"
                    title="Docker bridge forward"
                    data-help="Adds NAT rules so traffic from peers destined to the interface relay name/IP goes to the container bridge allowing peers to access other services running outside this container on the host network."
                    >docker fwd</span
                  >
                  <span
                    id="ifaceGatewayPill"
                    class="status-pill small feature off pill-gateway"
                    style="display: none"
                    title="VPN gateway"
                    data-help="If enabled, peers can use this server as a gateway to reach external networks (e.g. the Internet) via proper AllowedIPs (like 0.0.0.0/0) and server-side NAT/forward rules. Disable if you want the VPN to be used only for intra-tunnel/private traffic."
                    >vpn gateway</span
                  >
                </div>
                <div class="iface-stats" id="ifaceStats"></div>
              </div>
              <div class="iface-actions">
                <button id="btnRefresh" class="cog-btn" title="Refresh">
                  Refresh
                </button>
                <button
                  id="btnEnableService"
                  class="cog-btn"
                  title="Enable service"
                >
                  Enable
                </button>
                <button
                  id="btnDisableService"
                  class="cog-btn"
                  title="Disable service"
                >
                  Disable
                </button>
                <button
                  id="btnServerSettings"
                  class="cog-btn"
                  title="Edit server"
                >
                  Edit
                </button>
                <button
                  id="btnDeleteInterface"
                  class="btn-danger"
                  title="Delete Interface"
                >
                  Delete
                </button>
              </div>
            </div>
            <div class="peers-section">
              <div class="peers-layout">
                <div class="peers-left">
                  <div class="peers-section-header">
                    <div style="display: flex; align-items: center; gap: 8px">
                      <h3>Peers</h3>
                      <span
                        class="saving-indicator"
                        id="peerLoading"
                        style="display: none; font-size: 12px; color: #90a4ae"
                        >Loading...</span
                      >
                    </div>
                    <div class="peer-tools">
                      <span
                        id="emptyState"
                        class="empty-state"
                        style="padding: 0 4px; font-size: 12px; color: #7f95a1"
                      >
                        Select peer to display details.
                      </span>
                      <button
                        id="btnOpenAddPeer"
                        class="peer-add-btn btn-pop"
                        title="Add Peer"
                      >
                        +
                      </button>
                      <input
                        id="peerSearch"
                        class="peer-search"
                        type="text"
                        placeholder="Search"
                      />
                    </div>
                  </div>
                  <div id="peersContainer" class="peer-list"></div>
                </div>
                <div class="peer-detail-panel hidden" id="peerDetailPanel">
                  <div class="peer-detail-header" style="gap: 10px">
                    <h3
                      id="peerDetailTitle"
                      style="
                        flex: 1;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                      "
                    >
                      Peer
                      <span
                        class="help-icon"
                        id="peerNameHelp"
                        data-help="Note: On some Linux distributions the wireguard CLI (wg-quick) may modify resolv.conf or interact poorly when a DNS= line is present in a peer config, causing host DNS resolution issues. If you experience broken DNS after bringing an interface up, try removing the DNS line from the peer config and configuring DNS at the system or VPN server level instead."
                        >?</span
                      >
                    </h3>
                    <span
                      id="peerDetailStatusPill"
                      class="status-pill small"
                      style="display: none"
                      >offline</span
                    >
                    <div
                      class="peer-detail-actions"
                      style="display: flex; gap: 8px"
                    >
                      <button
                        class="download-btn"
                        id="btnDeletePeer"
                        title="Delete peer"
                      >
                        Delete
                      </button>
                      <button
                        class="download-btn"
                        id="btnEditPeer"
                        title="Edit peer"
                      >
                        Edit
                      </button>
                      <button
                        class="download-btn"
                        id="btnQrPeer"
                        title="Show QR code"
                      >
                        QR
                      </button>
                      <button
                        class="download-btn"
                        id="btnDownloadPeer"
                        title="Download peer config"
                      >
                        Download
                      </button>
                    </div>
                  </div>
                  <div class="peer-fields" id="peerFields">
                    <div class="peer-field">
                      <label>Public Key</label
                      ><input id="detailPublicKey" readonly />
                    </div>
                    <div class="peer-field dual-traffic">
                      <div class="traffic-col">
                        <label>IP</label><input id="detailIP" readonly />
                      </div>
                      <div class="traffic-col">
                        <label>Endpoint</label
                        ><input id="detailEndpoint" readonly />
                      </div>
                    </div>
                    <div class="peer-field dual-traffic">
                      <div class="traffic-col">
                        <label>Upload (from peer)</label
                        ><input id="detailDownload" readonly />
                      </div>
                      <div class="traffic-col">
                        <label>Download (to peer)</label
                        ><input id="detailUpload" readonly />
                      </div>
                    </div>
                    <div class="peer-field">
                      <label>Last Handshake</label
                      ><input id="detailHandshake" readonly />
                    </div>
                    <div class="peer-field">
                      <label>Config</label
                      ><textarea id="detailConfig" rows="8" readonly></textarea>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="toast" id="toast"></div>
    <div id="addInterfaceModal" style="display: none"></div>
    <div id="addPeerModal" style="display: none"></div>
    <div id="qrPeerModal" style="display: none"></div>
    <div id="editPeerModal" style="display: none"></div>
    <div id="editInterfaceModal" style="display: none"></div>
    <div id="deletePeerModal" style="display: none"></div>
    <div id="deleteInterfaceModal" style="display: none"></div>
    <div id="logoutModal" style="display: none"></div>
    <div id="interfaceSuccessModal" style="display: none"></div>
    <div id="settingsModal" style="display: none"></div>
    <script>
      // Unified app mode: direct API (same origin) no /proxy needed
      const apiBase = ""; // empty = root
      console.log(
        "[PyGuard] Dashboard script start (unified mode). apiBase=",
        apiBase
      );
      const headers = () => ({
        "Content-Type": "application/json",
      });
      const interfacesContainer = document.getElementById(
        "interfacesContainer"
      );
      const ifaceTitle = document.getElementById("ifaceTitle");
      const ifaceMeta = document.getElementById("ifaceStats");
      const ifaceActivePill = document.getElementById("ifaceActivePill");
      const ifaceDnsPill = document.getElementById("ifaceDnsPill");
      const ifaceDockerPill = document.getElementById("ifaceDockerPill");
      const ifaceGatewayPill = document.getElementById("ifaceGatewayPill");
      const islandEl = document.getElementById("island");
      const logoTitle = document.querySelector(".top-bar .logo-title");
      const peersContainer = document.getElementById("peersContainer");
      const peerLoading = document.getElementById("peerLoading");
      const emptyState = document.getElementById("emptyState");
      const peerDetailPanel = document.getElementById("peerDetailPanel");
      // Updated hide/show helpers: rely on .details-region.peer-open to control sizing so when hidden it occupies zero space.
      function hidePeerDetailPanel() {
        if (!peerDetailPanel) return;
        peerDetailPanel.classList.add("hidden");
        const region = islandEl.querySelector(".details-region");
        if (region) region.classList.remove("peer-open");
        islandEl.classList.remove("peer-open");
      }
      function showPeerDetailPanel() {
        if (!peerDetailPanel) return;
        peerDetailPanel.classList.remove("hidden");
        const region = islandEl.querySelector(".details-region");
        if (region) region.classList.add("peer-open");
        islandEl.classList.add("peer-open");
      }
      const editInterfaceModalMount =
        document.getElementById("editInterfaceModal");
      const btnServerSettings = document.getElementById("btnServerSettings");
      const peerDetailTitle = document.getElementById("peerDetailTitle");
      const peerDetailStatusPill = document.getElementById(
        "peerDetailStatusPill"
      );
      const btnDownloadPeer = document.getElementById("btnDownloadPeer");
      const btnEditPeer = document.getElementById("btnEditPeer");
      const btnQrPeer = document.getElementById("btnQrPeer");
      const detailPublicKey = document.getElementById("detailPublicKey");
      const detailIP = document.getElementById("detailIP");
      const detailEndpoint = document.getElementById("detailEndpoint");
      const detailDownload = document.getElementById("detailDownload");
      const detailUpload = document.getElementById("detailUpload");
      const detailHandshake = document.getElementById("detailHandshake");
      const detailConfig = document.getElementById("detailConfig");
      let serverNetwork = "";
      let currentServer = {};
      // Optional (editor not yet rendered in current template revision)
      const peerEditor = document.getElementById("peerEditor");
      const peerForm = document.getElementById("peerForm");
      const peerEditorTitle = document.getElementById("peerEditorTitle");
      const dirtyFlag = document.getElementById("dirtyFlag");
      const toastEl = document.getElementById("toast");
      const peerSearch = document.getElementById("peerSearch");
      const btnRefresh = document.getElementById("btnRefresh");
      const btnAddPeer = document.getElementById("btnAddPeer");
      const btnEnableService = document.getElementById("btnEnableService");
      const btnDisableService = document.getElementById("btnDisableService");
      const btnDeletePeer = document.getElementById("btnDeletePeer");
      const btnDeleteInterface = document.getElementById("btnDeleteInterface");
      const btnCancelEdit = document.getElementById("btnCancelEdit");
      let currentInterface = null;
      let peers = [];
      let originalPeerData = null;
      let currentPeerPublicKey = null;
      let currentPeerName = null;
      let peerDetailInterval = null;
      let lastPeerDetail = null;
      let interfaceRefreshInterval = null;
      let interfacesListInterval = null;
      function clearInterfaceRefreshInterval() {
        if (interfaceRefreshInterval) {
          clearInterval(interfaceRefreshInterval);
          interfaceRefreshInterval = null;
        }
      }
      function clearInterfacesListInterval() {
        if (interfacesListInterval) {
          clearInterval(interfacesListInterval);
          interfacesListInterval = null;
        }
      }
      function clearPeerDetailInterval() {
        if (peerDetailInterval) {
          clearInterval(peerDetailInterval);
          peerDetailInterval = null;
        }
      }
      function showToast(msg, ok = true) {
        toastEl.textContent = msg;
        toastEl.style.background = ok ? "#263844" : "#b71c1c";
        toastEl.classList.add("show");
        setTimeout(() => toastEl.classList.remove("show"), 2800);
      }
      async function fetchJSON(url, opts = {}) {
        try {
          const res = await fetch(url, opts);
          if (res.status === 401) {
            window.location = "/";
            return null;
          }
          const data = await res.json().catch(() => ({}));
          if (!res.ok) throw new Error(data.detail || res.statusText);
          return data;
        } catch (e) {
          showToast(e.message, false);
          throw e;
        }
      }
      let interfacesFetchInFlight = false;
      function isPeerOnlineFromRuntime(runtime) {
        if (!runtime) return null;
        const s = runtime.last_handshake_str;
        if (!s) return null;
        if (/never/i.test(s)) return false;
        if (
          typeof runtime.last_handshake === "number" &&
          runtime.last_handshake > 600
        )
          return false;
        return true;
      }
      async function loadInterfaces() {
        if (interfacesFetchInFlight) return;
        interfacesFetchInFlight = true;
        let data;
        try {
          data = await fetchJSON(`${apiBase}/interfaces`, {
            headers: headers(),
          });
        } catch (e) {
          console.error("Failed loading interfaces", e);
          interfacesFetchInFlight = false;
          return;
        }
        if (!data) {
          interfacesFetchInFlight = false;
          return;
        }
        // Show Docker Mode badge if in container
        try {
          const badge = document.getElementById("dockerModeBadge");
          if (badge) {
            if (
              data.PYGUARD_IN_DOCKER === true ||
              data.PYGUARD_IN_DOCKER === 1
            ) {
              badge.style.display = "inline-block";
            } else {
              badge.style.display = "none";
            }
          }
        } catch (_) {}
        const list = data.interfaces || [];
        // Build desired order and metadata
        const desired = list
          .map((obj) => ({
            name: obj && typeof obj === "object" ? obj.name : obj,
            active: obj && typeof obj === "object" ? !!obj.active : false,
          }))
          .filter((x) => !!x.name);

        // Build a map of existing elements
        const existing = new Map();
        Array.from(interfacesContainer.querySelectorAll(".iface-item")).forEach(
          (el) => {
            const n = el.dataset.name;
            if (n) existing.set(n, el);
          }
        );

        // Remove elements that no longer exist
        existing.forEach((el, n) => {
          if (!desired.find((d) => d.name === n)) {
            el.remove();
            existing.delete(n);
          }
        });

        // Ensure each desired item exists and update classes/content minimally
        desired.forEach(({ name, active }) => {
          let el = existing.get(name);
          if (!el) {
            el = document.createElement("div");
            el.className = "iface-item";
            el.dataset.name = name;
            el.onclick = () => selectInterface(name);
            el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
            existing.set(name, el);
          }
          // selection class
          el.classList.toggle("active", name === currentInterface);
          // name text
          const nameSpan = el.querySelector(".iface-name");
          if (nameSpan && nameSpan.textContent !== name)
            nameSpan.textContent = name;
          // status pill
          const pill = el.querySelector(".iface-pill");
          if (pill) {
            pill.classList.toggle("ok", !!active);
            pill.classList.toggle("bad", !active);
            pill.textContent = active ? "active" : "inactive";
            pill.title = active
              ? `Interface ${name} is up and running`
              : `Interface ${name} is not turned on, bring it up by pressing enable button`;
            pill.setAttribute(
              "data-help",
              active
                ? `Interface ${name} is up and running`
                : `Interface ${name} is not turned on, bring it up by pressing enable button`
            );
          }
        });

        // Reorder DOM to match desired order without full re-render
        desired.forEach(({ name }) => {
          const el = existing.get(name);
          if (el) interfacesContainer.appendChild(el);
        });

        // If no interfaces, show a placeholder once
        if (
          !desired.length &&
          !interfacesContainer.querySelector(".iface-empty")
        ) {
          const ph = document.createElement("div");
          ph.className = "iface-empty";
          ph.style.cssText = "padding:14px 16px;font-size:12px;color:#78909c;";
          ph.textContent = "No interfaces";
          interfacesContainer.appendChild(ph);
        } else if (desired.length) {
          const ph = interfacesContainer.querySelector(".iface-empty");
          if (ph) ph.remove();
        }
        interfacesFetchInFlight = false;
      }
      async function selectInterface(iface) {
        clearPeerDetailInterval();
        clearInterfaceRefreshInterval();
        // Reset any previously selected peer to avoid stale highlight when switching back
        currentPeerPublicKey = null;
        currentPeerName = null;
        lastPeerDetail = null;
        // Hide detail status pill until a peer is opened again
        if (peerDetailStatusPill) peerDetailStatusPill.style.display = "none";
        // Proactively remove any lingering active class from existing rows
        document
          .querySelectorAll(".peer-row.active")
          .forEach((r) => r.classList.remove("active"));
        currentInterface = iface;
        document
          .querySelectorAll(".iface-item")
          .forEach((i) =>
            i.classList.toggle("active", i.dataset.name === iface)
          );
        ifaceTitle.textContent = iface;
        ifaceMeta.innerHTML = "";
        peersContainer.innerHTML = "";
        // Reset to compact (no peer open) when switching/choosing interface
        islandEl.classList.remove("peer-open");
        islandEl
          .querySelector(".details-region")
          ?.classList.remove("peer-open");
        emptyState.style.display = "block";
        islandEl.classList.add("expanded");
        await loadInterfaceAll();
        // Start periodic refresh of interface peers/status every 5s
        interfaceRefreshInterval = setInterval(async () => {
          try {
            await loadInterfaceAll();
          } catch (_) {}
        }, 5000);
      }
      async function loadInterfaceAll() {
        if (!currentInterface) return;
        peerLoading.style.display = "inline";
        try {
          const data = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(currentInterface)}`,
            { headers: headers() }
          );
          if (!data) return;
          const s = data.server || {};
          serverNetwork = s.network || "";
          if (typeof data.forward_to_docker_bridge !== "undefined") {
            s.forward_to_docker_bridge = data.forward_to_docker_bridge;
          }
          if (typeof data["dns_service"] !== "undefined") {
            s["dns_service"] = data["dns_service"];
          }
          if (typeof data["allow_vpn_gateway"] !== "undefined") {
            s["allow_vpn_gateway"] = data["allow_vpn_gateway"];
          }
          if (typeof data["gateway_name"] !== "undefined") {
            window.PYGUARD_GATEWAY_NAME = data["gateway_name"];
          }
          if (typeof data.PYGUARD_IN_DOCKER !== "undefined") {
            window.PYGUARD_IN_DOCKER = data.PYGUARD_IN_DOCKER ? 1 : 0;
            try {
              const badge = document.getElementById("dockerModeBadge");
              if (badge) {
                if (window.PYGUARD_IN_DOCKER === 1) {
                  badge.style.display = "inline-block";
                } else {
                  badge.style.display = "none";
                }
              }
            } catch (_) {}
          }
          currentServer = s;
          const isActive = !!data.active;
          // Update active pill next to interface name
          if (ifaceActivePill) {
            ifaceActivePill.style.display = "inline-block";
            ifaceActivePill.classList.toggle("ok", isActive);
            ifaceActivePill.classList.toggle("bad", !isActive);
            ifaceActivePill.textContent = isActive ? "active" : "inactive";
            const nm = currentInterface || data?.interface || "interface";
            ifaceActivePill.title = isActive
              ? `Interface ${nm} is up and running`
              : `Interface ${nm} is not turned on, bring it up by pressing enable button`;
            ifaceActivePill.setAttribute(
              "data-help",
              isActive
                ? `Interface ${nm} is up and running`
                : `Interface ${nm} is not turned on, bring it up by pressing enable button`
            );
            // If user is already hovering/focused, refresh the tooltip content immediately
            try {
              if (
                ifaceActivePill.matches(":hover") ||
                document.activeElement === ifaceActivePill
              ) {
                ifaceActivePill.dispatchEvent(new Event("mouseenter"));
              }
            } catch (_) {}
          }
          // Update feature pills (DNS, Docker forward, VPN gateway)
          const dnsOn = !!(s["dns_service"] ?? s.dns_service ?? false);
          const dockerOn = !!(s.forward_to_docker_bridge ?? false);
          const gwOn = !!(
            s["allow_vpn_gateway"] ??
            s.allow_vpn_gateway ??
            false
          );
          // DNS: always visible when interface selected
          if (ifaceDnsPill) {
            ifaceDnsPill.style.display = "inline-block";
            ifaceDnsPill.classList.toggle("on", dnsOn);
            ifaceDnsPill.classList.toggle("off", !dnsOn);
            ifaceDnsPill.classList.toggle("pill-dns", dnsOn);
            ifaceDnsPill.textContent = "dns";
            const dnsName = "DNS service";
            const dnsMsg = dnsOn
              ? `${dnsName} is active`
              : `${dnsName} is disabled, check its usage in edit window`;
            ifaceDnsPill.title = dnsMsg;
            ifaceDnsPill.setAttribute("data-help", dnsMsg);
            try {
              if (
                ifaceDnsPill.matches(":hover") ||
                document.activeElement === ifaceDnsPill
              ) {
                ifaceDnsPill.dispatchEvent(new Event("mouseenter"));
              }
            } catch (_) {}
          }
          // Docker forward: only when running in Docker mode
          if (ifaceDockerPill) {
            const inDocker =
              window.PYGUARD_IN_DOCKER === 1 ||
              window.PYGUARD_IN_DOCKER === true;
            ifaceDockerPill.style.display = inDocker ? "inline-block" : "none";
            if (inDocker) {
              ifaceDockerPill.classList.toggle("on", dockerOn);
              ifaceDockerPill.classList.toggle("off", !dockerOn);
              ifaceDockerPill.textContent = "docker fwd";
              const dockName = "Docker bridge forward";
              const dockMsg = dockerOn
                ? `${dockName} is active`
                : `${dockName} is disabled, check its usage in edit window`;
              ifaceDockerPill.title = dockMsg;
              ifaceDockerPill.setAttribute("data-help", dockMsg);
              try {
                if (
                  ifaceDockerPill.matches(":hover") ||
                  document.activeElement === ifaceDockerPill
                ) {
                  ifaceDockerPill.dispatchEvent(new Event("mouseenter"));
                }
              } catch (_) {}
            }
          }
          // VPN gateway: always visible
          if (ifaceGatewayPill) {
            ifaceGatewayPill.style.display = "inline-block";
            ifaceGatewayPill.classList.toggle("on", gwOn);
            ifaceGatewayPill.classList.toggle("off", !gwOn);
            ifaceGatewayPill.textContent = "vpn gateway";
            const gwName = "VPN gateway";
            const gwMsg = gwOn
              ? `${gwName} is active`
              : `${gwName} is disabled, check its usage in edit window`;
            ifaceGatewayPill.title = gwMsg;
            ifaceGatewayPill.setAttribute("data-help", gwMsg);
            try {
              if (
                ifaceGatewayPill.matches(":hover") ||
                document.activeElement === ifaceGatewayPill
              ) {
                ifaceGatewayPill.dispatchEvent(new Event("mouseenter"));
              }
            } catch (_) {}
          }
          // Highlight Enable button if inactive
          try {
            const enableBtn = document.getElementById("btnEnableService");
            const disableBtn = document.getElementById("btnDisableService");
            if (enableBtn) {
              if (!isActive) {
                enableBtn.classList.add("btn-enable-pulse");
              } else {
                enableBtn.classList.remove("btn-enable-pulse");
              }
            }
            if (disableBtn && !isActive) {
              disableBtn.classList.remove("btn-enable-pulse");
            }
          } catch (_) {}
          let peersData = data.peers || {};
          if (typeof peersData === "string") {
            try {
              const parsed = JSON.parse(peersData);
              // legacy format may wrap in { peers: {..} }
              if (parsed && parsed.peers && typeof parsed.peers === "object")
                peersData = parsed.peers;
              else peersData = parsed;
            } catch (e) {
              console.warn("Failed to parse peers JSON string", e);
              peersData = {};
            }
          }
          const peerNames = Object.keys(peersData);
          const peerCount = data.peer_count ?? peerNames.length;
          const stats = [
            { label: "Network", value: s.network || "-" },
            { label: "relay ip", value: s.ip || "—" },
            { label: "Port", value: s.port || "-" },
            { label: "Peers", value: peerCount },
            { label: "Public IP", value: s.public_ip || "—" },
          ];
          ifaceMeta.innerHTML = stats
            .map(
              (st) =>
                `<div class="iface-stat"><span class="label">${st.label}</span><span>${st.value}</span></div>`
            )
            .join("");
          peers = peerNames.map((name) => {
            const info = peersData[name] || {};
            return {
              public_key: info.public_key || name, // in case we add later
              name,
              active: !!info.active,
              last_handshake: info.last_handshake || null,
              last_handshake_str: info.last_handshake_str || "",
              // NOTE: From relay/server perspective the original fields reflect server rx/tx.
              // UI labels were swapped to show Upload(from peer)->server as 'Upload' first.
              download: info.download || "0 KiB", // bytes received by server from peer (peer upload)
              uploaded: info.uploaded || "0 KiB", // bytes sent by server to peer (peer download)
            };
          });
          console.debug("Loaded peers (with status)", peers);
          renderPeerList();
        } finally {
          peerLoading.style.display = "none";
        }

        // Initialize tooltips for pills after loading interface
        if (typeof initHelpTooltips === "function") {
          try {
            initHelpTooltips(document);
          } catch (_) {}
        }
      }
      function renderPeerList() {
        const q = peerSearch.value.trim().toLowerCase();
        peersContainer.innerHTML = "";
        const filtered = peers.filter(
          (p) =>
            !q ||
            p.name.toLowerCase().includes(q) ||
            (p.public_key || "").toLowerCase().includes(q)
        );
        if (!filtered.length) {
          peersContainer.innerHTML =
            '<div style="padding:16px;font-size:12px;color:#78909c;">No peers</div>';
          return;
        }
        filtered.forEach((p) => {
          const el = document.createElement("div");
          el.className =
            "peer-row" +
            (p.public_key === currentPeerPublicKey ? " active" : "");
          // Attach identifiers for precise selection
          el.dataset.pubkey = p.public_key || p.name;
          el.dataset.name = p.name;
          const pill = `<span class=\"status-pill small ${
            p.active ? "ok" : "bad"
          }\" title=\"${p.active ? "Online" : "Offline"}\" data-help=\"${
            p.active
              ? "This peer has had a recent handshake with the server and is considered online."
              : "This peer has not had a recent handshake or has been offline for more than 10 minutes."
          }\">${p.active ? "online" : "offline"}</span>`;
          const showKey = p.public_key && p.public_key !== p.name;
          const keyFrag = showKey
            ? `<span>${(p.public_key || "").slice(0, 14)}...</span>`
            : "";
          el.innerHTML = `<div class="line1"><span style="display:flex;align-items:center;gap:6px;"><span>${p.name}</span></span><span>${pill}</span></div><div class="line2">${keyFrag}<span>U:${p.download} D:${p.uploaded}</span></div>`;
          el.onclick = () => openPeer(p.public_key || p.name);
          peersContainer.appendChild(el);
        });

        // Initialize tooltips for newly rendered peer pills
        if (typeof initHelpTooltips === "function") {
          try {
            initHelpTooltips(peersContainer);
          } catch (_) {}
        }
      }
      function setPeerDetailLoading(loading) {
        const fields = [
          detailPublicKey,
          detailIP,
          detailEndpoint,
          detailDownload,
          detailUpload,
          detailHandshake,
          detailConfig,
        ];
        fields.forEach((el) => {
          if (!el) return;
          if (loading) {
            el.setAttribute("disabled", "true");
            el.setAttribute("aria-busy", "true");
            el.classList.add("input-loading");
          } else {
            el.removeAttribute("disabled");
            el.removeAttribute("aria-busy");
            el.classList.remove("input-loading");
          }
        });
      }
      async function openPeer(pub) {
        const p = peers.find((x) => x.public_key === pub);
        if (!p) return;
        currentPeerPublicKey = pub;
        currentPeerName = p.name;
        clearPeerDetailInterval();
        // Highlight only the exact selected row
        document
          .querySelectorAll(".peer-row")
          .forEach((r) =>
            r.classList.toggle("active", r.dataset.pubkey === pub)
          );
        if (emptyState) emptyState.style.display = "none";
        if (peerEditor) peerEditor.style.display = "block";
        if (peerEditorTitle) peerEditorTitle.textContent = `Peer: ${p.name}`;
        if (peerDetailPanel) {
          islandEl.querySelector(".details-region")?.classList.add("peer-open");
          islandEl.classList.add("peer-open");
          showPeerDetailPanel();
        }
        // Start shimmer loading on peer detail fields
        setPeerDetailLoading(true);
        // Fetch detailed peer info
        try {
          const detail = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/peers/${encodeURIComponent(p.name)}`,
            { headers: headers() }
          );
          if (detail && detail.peer_data) {
            const d = detail.peer_data;
            lastPeerDetail = detail;
            if (peerForm) {
              if (peerForm.peerName) peerForm.peerName.value = p.name;
              if (peerForm.peerAddress) peerForm.peerAddress.value = d.ip || "";
              if (peerForm.peerAllowedIPs)
                peerForm.peerAllowedIPs.value = d.allowed_ips || "";
              if (peerForm.peerEndpoint)
                peerForm.peerEndpoint.value = d.endpoint || "";
              if (peerForm.peerPersistentKeepalive)
                peerForm.peerPersistentKeepalive.value =
                  d.persistent_keepalive || "";
              if (peerForm.peerDNS) peerForm.peerDNS.value = "";
              if (peerForm.peerPrivateKey) peerForm.peerPrivateKey.value = "";
              if (peerForm.peerNotes) peerForm.peerNotes.value = d.notes || "";
            }
            // Read-only meta fields
            const pubKeyEl = document.getElementById("peerPublicKey");
            const serverEpEl = document.getElementById("serverEndpoint");
            if (pubKeyEl)
              pubKeyEl.value =
                d.public_key || detail.public_key || p.public_key || "";
            const ep = detail.server_endpoint_host
              ? `${detail.server_endpoint_host}:${
                  detail.server_port || ""
                }`.replace(/:$/, "")
              : "";
            if (serverEpEl) serverEpEl.value = ep;
            // Populate panel
            if (peerDetailPanel) {
              // Update peer detail title while preserving the embedded help icon
              if (peerDetailTitle) {
                const helpIcon = peerDetailTitle.querySelector("#peerNameHelp");
                peerDetailTitle.innerHTML = `${p.name}`;
                if (helpIcon) peerDetailTitle.appendChild(helpIcon);
                // Store clean name separate from visible text (which includes help icon '?')
                peerDetailTitle.dataset.peerName = p.name;
              }
              if (typeof initHelpTooltips === "function") {
                const scope = peerDetailTitle?.parentElement || document;
                initHelpTooltips(scope);
              }
              detailPublicKey.value = d.public_key || p.public_key || "";
              detailIP.value = d.ip || "";
              detailEndpoint.value = d.endpoint || "";
              const runtime = detail.runtime || {};
              detailDownload.value = runtime.rx_human || p.download || "";
              detailUpload.value = runtime.tx_human || p.uploaded || "";
              detailHandshake.value = runtime.last_handshake_str
                ? runtime.last_handshake_str
                : p.last_handshake_str || "—";
              detailConfig.value =
                detail.config_text || detail.peer_config || "";
              btnDownloadPeer.onclick = () =>
                downloadPeerConfig(
                  p.name,
                  detail.config_text || detail.peer_config || ""
                );
              // update detail status pill
              const online =
                isPeerOnlineFromRuntime(runtime) ?? p.active ? true : false;
              if (peerDetailStatusPill) {
                peerDetailStatusPill.style.display = "inline-block";
                peerDetailStatusPill.classList.toggle("ok", online);
                peerDetailStatusPill.classList.toggle("bad", !online);
                peerDetailStatusPill.textContent = online
                  ? "online"
                  : "offline";
                peerDetailStatusPill.title = online ? "Online" : "Offline";
                peerDetailStatusPill.setAttribute(
                  "data-help",
                  online
                    ? "This peer has had a recent handshake with the server and is considered online."
                    : "This peer has not had a recent handshake or has been offline for more than 10 minutes."
                );
              }
            }
          } else {
            lastPeerDetail = null;
            if (peerForm) {
              if (peerForm.peerName) peerForm.peerName.value = p.name;
              if (peerForm.peerAddress) peerForm.peerAddress.value = "";
              if (peerForm.peerAllowedIPs) peerForm.peerAllowedIPs.value = "";
              if (peerForm.peerEndpoint) peerForm.peerEndpoint.value = "";
              if (peerForm.peerPersistentKeepalive)
                peerForm.peerPersistentKeepalive.value = "";
              if (peerForm.peerDNS) peerForm.peerDNS.value = "";
              if (peerForm.peerPrivateKey) peerForm.peerPrivateKey.value = "";
              if (peerForm.peerNotes) peerForm.peerNotes.value = "";
            }
            const pubKeyEl = document.getElementById("peerPublicKey");
            const serverEpEl = document.getElementById("serverEndpoint");
            if (pubKeyEl) pubKeyEl.value = p.public_key || "";
            if (serverEpEl) serverEpEl.value = "";
            if (peerDetailPanel) {
              if (peerDetailTitle) {
                const helpIcon = peerDetailTitle.querySelector("#peerNameHelp");
                peerDetailTitle.innerHTML = `${p.name}`;
                if (helpIcon) peerDetailTitle.appendChild(helpIcon);
                // Keep a clean copy of name for programmatic use
                peerDetailTitle.dataset.peerName = p.name;
              }
              if (typeof initHelpTooltips === "function") {
                const scope = peerDetailTitle?.parentElement || document;
                initHelpTooltips(scope);
              }
              detailPublicKey.value = p.public_key || "";
              detailIP.value = "";
              detailEndpoint.value = "";
              detailDownload.value = p.download || "";
              detailUpload.value = p.uploaded || "";
              detailHandshake.value = p.last_handshake_str || "—";
              detailConfig.value = "";
              btnDownloadPeer.onclick = () => showToast("No config yet", false);
              if (peerDetailStatusPill) {
                peerDetailStatusPill.style.display = "inline-block";
                peerDetailStatusPill.classList.toggle("ok", !!p.active);
                peerDetailStatusPill.classList.toggle("bad", !p.active);
                peerDetailStatusPill.textContent = p.active
                  ? "online"
                  : "offline";
                peerDetailStatusPill.title = p.active ? "Online" : "Offline";
                peerDetailStatusPill.setAttribute(
                  "data-help",
                  p.active
                    ? "This peer has had a recent handshake with the server and is considered online."
                    : "This peer has not had a recent handshake or has been offline for more than 10 minutes."
                );
              }
            }
          }
        } catch (e) {
          /* toast already shown */
        } finally {
          // End shimmer loading regardless of outcome
          setPeerDetailLoading(false);
        }
        originalPeerData = serializeForm();
        if (dirtyFlag) dirtyFlag.style.display = "none";
        // Start periodic refresh (every 5s)
        peerDetailInterval = setInterval(
          () => refreshCurrentPeerRuntime(),
          5000
        );
      }
      async function refreshCurrentPeerRuntime() {
        if (!currentInterface || !currentPeerName) return;
        try {
          const detail = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/peers/${encodeURIComponent(currentPeerName)}`,
            { headers: headers() }
          );
          if (!detail || !detail.peer_data) return;
          const runtime = detail.runtime || {};
          // Update endpoint (unlikely to change often but keep fresh)
          if (detail?.peer_data?.endpoint && detailEndpoint) {
            detailEndpoint.value = detail.peer_data.endpoint;
          }
          // Update peer detail panel fields if still selected
          const titleName =
            peerDetailTitle &&
            peerDetailTitle.dataset &&
            peerDetailTitle.dataset.peerName
              ? peerDetailTitle.dataset.peerName
              : peerDetailTitle
              ? peerDetailTitle.textContent.trim()
              : "";
          if (titleName === currentPeerName) {
            // traffic + handshake
            detailDownload.value =
              runtime.rx_human ||
              detail.peer_data.download ||
              detail.peer_data.transfer_rx_bytes_human ||
              "";
            detailUpload.value =
              runtime.tx_human ||
              detail.peer_data.uploaded ||
              detail.peer_data.transfer_tx_bytes_human ||
              "";
            detailHandshake.value =
              runtime.last_handshake_str ||
              detail.peer_data.last_handshake_str ||
              "—";
          }
          // Update peers array entry & list row
          const idx = peers.findIndex((pr) => pr.name === currentPeerName);
          if (idx >= 0) {
            peers[idx].last_handshake_str =
              runtime.last_handshake_str || peers[idx].last_handshake_str;
            // Reconstruct download/upload from runtime if available (choose rx/tx_human or keep previous)
            if (runtime.rx_human && runtime.tx_human) {
              peers[idx].download = runtime.rx_human;
              peers[idx].uploaded = runtime.tx_human;
            }
            peers[idx].active = runtime.last_handshake_str
              ? !/never/i.test(runtime.last_handshake_str) &&
                !(runtime.last_handshake && runtime.last_handshake > 600)
              : peers[idx].active;
          }
          // Update DOM row for current peer
          const rows = peersContainer.querySelectorAll(".peer-row");
          rows.forEach((row) => {
            const nameEl = row.querySelector(".line1 span span");
            if (nameEl && nameEl.textContent === currentPeerName) {
              const line2 = row.querySelector(".line2");
              if (line2) {
                const peerObj = peers[idx];
                const showKey =
                  peerObj.public_key && peerObj.public_key !== peerObj.name;
                const keyFrag = showKey
                  ? `<span>${(peerObj.public_key || "").slice(0, 14)}...</span>`
                  : "";
                line2.innerHTML = `${keyFrag}<span>D:${peerObj.download} U:${peerObj.uploaded}</span>`;
              }
              const pillEl = row.querySelector(".status-pill");
              if (pillEl) {
                pillEl.classList.toggle("ok", peers[idx].active);
                pillEl.classList.toggle("bad", !peers[idx].active);
                pillEl.textContent = peers[idx].active ? "online" : "offline";
                pillEl.title = peers[idx].active ? "Online" : "Offline";
                pillEl.setAttribute(
                  "data-help",
                  peers[idx].active
                    ? "This peer has had a recent handshake with the server and is considered online."
                    : "This peer has not had a recent handshake or has been offline for more than 10 minutes."
                );
              }
            }
          });
          // Update detail header pill as well
          const online =
            isPeerOnlineFromRuntime(runtime) ?? peers[idx]?.active
              ? true
              : false;
          if (peerDetailStatusPill) {
            peerDetailStatusPill.style.display = "inline-block";
            peerDetailStatusPill.classList.toggle("ok", online);
            peerDetailStatusPill.classList.toggle("bad", !online);
            peerDetailStatusPill.textContent = online ? "online" : "offline";
            peerDetailStatusPill.title = online ? "Online" : "Offline";
            peerDetailStatusPill.setAttribute(
              "data-help",
              online
                ? "This peer has had a recent handshake with the server and is considered online."
                : "This peer has not had a recent handshake or has been offline for more than 10 minutes."
            );
          }
        } catch (e) {
          /* ignore refresh errors */
        }
      }
      function downloadPeerConfig(name, text) {
        if (!text) {
          showToast("Config empty", false);
          return;
        }
        const blob = new Blob([text], { type: "text/plain" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `${name}.conf`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(a.href);
          a.remove();
        }, 1200);
        showToast("Config downloaded");
      }
      function serializeForm() {
        if (!peerForm) return {};
        return {
          name: peerForm.peerName?.value.trim() || "",
          address: peerForm.peerAddress?.value.trim() || "",
          allowed_ips: peerForm.peerAllowedIPs?.value.trim() || "",
          endpoint: peerForm.peerEndpoint?.value.trim() || "",
          persistent_keepalive:
            peerForm.peerPersistentKeepalive?.value.trim() || "",
          dns: peerForm.peerDNS?.value.trim() || "",
          private_key: peerForm.peerPrivateKey?.value.trim() || "",
          notes: peerForm.peerNotes?.value.trim() || "",
        };
      }
      function detectDirty() {
        if (!peerForm || !originalPeerData || !dirtyFlag) return;
        const now = serializeForm();
        const dirty = Object.keys(now).some(
          (k) => now[k] !== originalPeerData[k]
        );
        dirtyFlag.style.display = dirty ? "inline" : "none";
      }
      if (peerForm) {
        peerForm.addEventListener("input", detectDirty);
        peerForm.addEventListener("submit", (e) => {
          e.preventDefault();
          showToast("Peer save not implemented yet", false);
        });
      }
      // Delete peer modal wiring
      const deletePeerModalMount = document.getElementById("deletePeerModal");
      const deleteInterfaceModalMount = document.getElementById(
        "deleteInterfaceModal"
      );
      function buildDeletePeerModal(name) {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="dpmClose" aria-label="Close">×</button>\n    <h3>Delete Peer</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to delete peer <b>${name}</b>?</div>\n    <div id="dpmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0; margin-top:8px;"></div>\n    <div class="pm-actions">\n      <button type="button" id="dpmCancel" class="btn-press">Cancel</button>\n      <button type="button" id="dpmDelete" class="btn-danger btn-press">Delete</button>\n    </div>\n  </div>\n</div>`;
      }
      async function openDeletePeerModal() {
        if (!currentInterface || !currentPeerName) {
          showToast("Select a peer first", false);
          return;
        }
        deletePeerModalMount.innerHTML = buildDeletePeerModal(currentPeerName);
        deletePeerModalMount.style.display = "block";
        const overlay = deletePeerModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = deletePeerModalMount.querySelector("#dpmClose");
        const btnCancel = deletePeerModalMount.querySelector("#dpmCancel");
        const btnGo = deletePeerModalMount.querySelector("#dpmDelete");
        const feedback = deletePeerModalMount.querySelector("#dpmFeedback");
        function close() {
          deletePeerModalMount.style.display = "none";
          deletePeerModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnGo.onclick = async () => {
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Deleting...";
          try {
            const res = await fetch(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/${encodeURIComponent(currentPeerName)}/delete`,
              { method: "POST", headers: headers() }
            );
            if (!res.ok) {
              const d = await res.json().catch(() => ({}));
              throw new Error(d.detail || res.statusText);
            }
            close();
            showToast("Peer deleted");
            clearPeerDetailInterval();
            currentPeerPublicKey = null;
            currentPeerName = null;
            lastPeerDetail = null;
            const detailsRegion = islandEl.querySelector(".details-region");
            if (detailsRegion) detailsRegion.classList.remove("peer-open");
            islandEl.classList.remove("peer-open");
            hidePeerDetailPanel();
            // Refresh peers
            await loadInterfaceAll();
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Delete failed"}`;
          }
        };
      }
      if (btnDeletePeer) btnDeletePeer.onclick = openDeletePeerModal;
      // Delete interface modal wiring (mirrors peer deletion)
      function buildDeleteInterfaceModal(name) {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="dimClose" aria-label="Close">×</button>\n    <h3>Delete Interface</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to delete interface <b>${name}</b>? This will remove its config and peers.</div>\n    <div id="dimFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0; margin-top:8px;"></div>\n    <div class="pm-actions">\n      <button type="button" id="dimCancel" class="btn-press">Cancel</button>\n      <button type="button" id="dimDelete" class="btn-danger btn-press">Delete</button>\n    </div>\n  </div>\n</div>`;
      }
      async function openDeleteInterfaceModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        deleteInterfaceModalMount.innerHTML =
          buildDeleteInterfaceModal(currentInterface);
        deleteInterfaceModalMount.style.display = "block";
        const overlay = deleteInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = deleteInterfaceModalMount.querySelector("#dimClose");
        const btnCancel = deleteInterfaceModalMount.querySelector("#dimCancel");
        const btnGo = deleteInterfaceModalMount.querySelector("#dimDelete");
        const feedback =
          deleteInterfaceModalMount.querySelector("#dimFeedback");
        function close() {
          deleteInterfaceModalMount.style.display = "none";
          deleteInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnGo.onclick = async () => {
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Deleting...";
          try {
            const name = currentInterface;
            const res = await fetch(
              `${apiBase}/interfaces/${encodeURIComponent(name)}/delete`,
              { method: "POST", headers: headers() }
            );
            if (!res.ok) {
              const d = await res.json().catch(() => ({}));
              throw new Error(d.detail || res.statusText);
            }
            const payload = await res.json().catch(() => ({}));
            // Update interface list from response
            const list = Array.isArray(payload?.interfaces)
              ? payload.interfaces
              : [];
            const desired = list
              .map((obj) => ({
                name: obj && typeof obj === "object" ? obj.name : obj,
                active: obj && typeof obj === "object" ? !!obj.active : false,
              }))
              .filter((x) => !!x.name);
            const existing = new Map();
            Array.from(
              interfacesContainer.querySelectorAll(".iface-item")
            ).forEach((el) => {
              const n = el.dataset.name;
              if (n) existing.set(n, el);
            });
            // Remove deleted element (if still present)
            existing.forEach((el, n) => {
              if (!desired.find((d) => d.name === n)) {
                el.remove();
                existing.delete(n);
              }
            });
            desired.forEach(({ name, active }) => {
              let el = existing.get(name);
              if (!el) {
                el = document.createElement("div");
                el.className = "iface-item";
                el.dataset.name = name;
                el.onclick = () => selectInterface(name);
                el.innerHTML = `<span class=\"iface-name\"></span><span class=\"iface-pill status-pill small\"></span>`;
                existing.set(name, el);
              }
              el.classList.toggle("active", false);
              const ns = el.querySelector(".iface-name");
              if (ns && ns.textContent !== name) ns.textContent = name;
              const pill = el.querySelector(".iface-pill");
              if (pill) {
                pill.classList.toggle("ok", !!active);
                pill.classList.toggle("bad", !active);
                pill.textContent = active ? "active" : "inactive";
                pill.title = active ? "Active" : "Inactive";
              }
              interfacesContainer.appendChild(el);
            });
            // Show placeholder when empty
            let ph = interfacesContainer.querySelector(".iface-empty");
            if (desired.length === 0) {
              if (!ph) {
                ph = document.createElement("div");
                ph.className = "iface-empty";
                ph.style.cssText =
                  "padding:14px 16px;font-size:12px;color:#78909c;";
                ph.textContent = "No interfaces";
                interfacesContainer.appendChild(ph);
              }
            } else if (ph) {
              ph.remove();
            }
            // Deselect current interface and reverse selection animation
            const detailsRegion = islandEl.querySelector(".details-region");
            if (detailsRegion) {
              detailsRegion.classList.remove("peer-open");
            }
            islandEl.classList.remove("peer-open");
            hidePeerDetailPanel();
            islandEl.classList.remove("expanded");
            ifaceTitle.textContent = "";
            ifaceMeta.innerHTML = "";
            peersContainer.innerHTML = "";
            emptyState.style.display = "block";
            clearPeerDetailInterval();
            clearInterfaceRefreshInterval();
            document
              .querySelectorAll(".iface-item")
              .forEach((i) => i.classList.remove("active"));
            currentInterface = null;
            close();
            showToast("Interface deleted");
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Delete failed"}`;
          }
        };
      }
      if (btnDeleteInterface)
        btnDeleteInterface.onclick = openDeleteInterfaceModal;
      if (btnEnableService)
        btnEnableService.onclick = async () => {
          if (!currentInterface) {
            showToast("Select an interface first", false);
            return;
          }
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/service/enable`,
              { method: "POST", headers: headers() }
            );
            // Update interface list using returned data if present
            if (res && Array.isArray(res.data)) {
              // Minimal: force a refresh by rebuilding with returned list
              // Build a fake response to feed existing loadInterfaces logic
              const list = res.data;
              // Update DOM directly similar to loadInterfaces diff routine
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  const msgOn = `Interface ${name} is up and running`;
                  const msgOff = `Interface ${name} is not turned on, bring it up by pressing enable button`;
                  pill.title = active ? msgOn : msgOff;
                  pill.setAttribute("data-help", active ? msgOn : msgOff);
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            // Also refresh current interface summary to update active pill
            await loadInterfaceAll();
            showToast("Service enabled");
          } catch (e) {
            /* toast already shown */
          }
        };
      if (btnDisableService)
        btnDisableService.onclick = async () => {
          if (!currentInterface) {
            showToast("Select an interface first", false);
            return;
          }
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/service/disable`,
              { method: "POST", headers: headers() }
            );
            if (res && Array.isArray(res.data)) {
              const list = res.data;
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class=\"iface-name\"></span><span class=\"iface-pill status-pill small\"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  const msgOn = `Interface ${name} is up and running`;
                  const msgOff = `Interface ${name} is not turned on, bring it up by pressing enable button`;
                  pill.title = active ? msgOn : msgOff;
                  pill.setAttribute("data-help", active ? msgOn : msgOff);
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            await loadInterfaceAll();
            showToast("Service disabled");
          } catch (e) {
            /* toast already shown */
          }
        };
      // Add Peer modal logic
      const addInterfaceModalMount =
        document.getElementById("addInterfaceModal");
      const addPeerModalMount = document.getElementById("addPeerModal");
      const qrPeerModalMount = document.getElementById("qrPeerModal");
      const editPeerModalMount = document.getElementById("editPeerModal");
      function buildAddPeerModal(ipPrefill) {
        const allowedPrefill = serverNetwork || "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="pmClose" aria-label="Close">×</button>\n    <h3>Add Peer</h3>\n    <form id="pmForm" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="pmName">Peer Name</label>\n        <input id="pmName" name="name" placeholder="e.g. laptop" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="pmIP">Peer IP</label>\n        <input id="pmIP" name="ip" value="${
          ipPrefill || ""
        }" placeholder="Auto if blank"/>\n      </div>\n      <div class="pm-field">\n        <label for="pmAllowed">Allowed IPs</label>\n        <input id="pmAllowed" name="allowed_ips" value="${allowedPrefill}" placeholder="e.g. ${
          allowedPrefill || "0.0.0.0/0"
        }"/>\n      </div>\n      <div id="pmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="pmCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="pmValidate" class="btn-glow">Create</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function ensureServerNetwork() {
        // If we didn't capture the network during interface load, fetch it now.
        if (!currentInterface || serverNetwork) return;
        try {
          const d = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(currentInterface)}`,
            { headers: headers() }
          );
          serverNetwork = d?.server?.network || "";
        } catch (_) {
          /* non-fatal */
        }
      }
      async function fetchNextAvailable() {
        if (!currentInterface) return null;
        try {
          const d = await fetchJSON(
            `${apiBase}/interfaces/${encodeURIComponent(
              currentInterface
            )}/next_available`,
            { headers: headers() }
          );
          return d?.next_available_ip || null;
        } catch {
          return null;
        }
      }
      async function openAddPeerModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        // Ensure we have the latest server network to prefill Allowed IPs
        await ensureServerNetwork();
        const ip = await fetchNextAvailable();
        addPeerModalMount.innerHTML = buildAddPeerModal(ip);
        addPeerModalMount.style.display = "block";
        const overlay = addPeerModalMount.querySelector(".peer-modal-overlay");
        const form = addPeerModalMount.querySelector("#pmForm");
        const btnCancel = addPeerModalMount.querySelector("#pmCancel");
        const btnClose = addPeerModalMount.querySelector("#pmClose");
        const feedback = addPeerModalMount.querySelector("#pmFeedback");
        const nameInput = addPeerModalMount.querySelector("#pmName");
        const ipInput = addPeerModalMount.querySelector("#pmIP");
        const allowedInput = addPeerModalMount.querySelector("#pmAllowed");
        nameInput.focus();
        function close() {
          addPeerModalMount.style.display = "none";
          addPeerModalMount.innerHTML = "";
        }
        btnCancel.onclick = close;
        btnClose.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          const name = nameInput.value.trim();
          const ipVal = ipInput.value.trim();
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name required";
            return;
          }
          const allowed = (allowedInput.value || "").trim();
          const payload = ipVal ? { name, ip: ipVal } : { name };
          if (allowed) payload.new_allowed = allowed;
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/validate`,
              {
                method: "POST",
                headers: headers(),
                body: JSON.stringify(payload),
              }
            );
            if (res && res.ok) {
              feedback.style.color = "#32c861";
              feedback.textContent = "Validated. Creating...";
              // Build creation payload expected by API (AddPeerReq)
              const finalIP = ipVal || ip || "";
              const finalAllowed = allowed || serverNetwork || "";
              if (!finalIP) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent =
                  "No available IP; try again or specify an IP.";
                return;
              }
              if (!finalAllowed) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent = "Allowed IPs required; fill the field.";
                return;
              }
              const createBody = {
                name,
                peer_ip: finalIP,
                allowed_ips: finalAllowed,
              };
              try {
                const createRes = await fetch(
                  `${apiBase}/interfaces/${encodeURIComponent(
                    currentInterface
                  )}/peers/add`,
                  {
                    method: "POST",
                    headers: headers(),
                    body: JSON.stringify(createBody),
                  }
                );
                const createdData = await createRes.json().catch(() => ({}));
                if (!createRes.ok) {
                  throw new Error(
                    createdData.detail ||
                      createRes.statusText ||
                      "Create failed"
                  );
                }
                // Update local peers list from returned peers object
                let peersData = createdData || {};
                if (typeof peersData === "string") {
                  try {
                    peersData = JSON.parse(peersData);
                  } catch {
                    peersData = {};
                  }
                }
                const names = Object.keys(peersData);
                peers = names.map((n) => {
                  const info = peersData[n] || {};
                  return {
                    public_key: info.public_key || n,
                    name: n,
                    active: !!info.active,
                    last_handshake: info.last_handshake || null,
                    last_handshake_str: info.last_handshake_str || "",
                    download: info.download || "0 KiB",
                    uploaded: info.uploaded || "0 KiB",
                  };
                });
                renderPeerList();
                // Close modal and select newly created peer
                close();
                showToast("Peer created");
                const createdPeer = peers.find((p) => p.name === name);
                if (createdPeer) {
                  openPeer(createdPeer.public_key || createdPeer.name);
                }
              } catch (err) {
                feedback.style.color = "#ff6b6b";
                feedback.textContent = `Create failed: ${
                  err.message || "error"
                }`;
              }
            } else {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = (res && res.detail) || "Validation failed";
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err.message || "Validation error"
            }`;
          }
        });
      }
      const btnOpenAddPeer = document.getElementById("btnOpenAddPeer");
      const btnOpenAddInterface = document.getElementById(
        "btnOpenAddInterface"
      );
      if (btnOpenAddPeer)
        btnOpenAddPeer.addEventListener("click", openAddPeerModal);
      if (btnAddPeer) btnAddPeer.onclick = openAddPeerModal;
      // Edit Interface modal
      function buildEditInterfaceModal(prefill, loading = false) {
        const name = prefill?.name ?? currentInterface ?? "";
        const port = prefill?.port ?? currentServer?.port ?? "";
        const network = prefill?.network ?? currentServer?.network ?? "";
        const public_ip = prefill?.public_ip ?? currentServer?.public_ip ?? "";
        const dns = prefill?.dns ?? currentServer?.dns ?? "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        const chkDis = loading ? "disabled" : "";
        const forward_to_docker_bridge =
          prefill?.forward_to_docker_bridge ??
          currentServer?.forward_to_docker_bridge ??
          false;
        const dns_service =
          prefill?.dns_service ??
          currentServer?.["dns_service"] ??
          currentServer?.dns_service ??
          false;
        const allow_vpn_gateway =
          prefill?.allow_vpn_gateway ??
          currentServer?.["allow_vpn_gateway"] ??
          currentServer?.allow_vpn_gateway ??
          false;
        const showFwd =
          window.PYGUARD_IN_DOCKER === 1 || window.PYGUARD_IN_DOCKER === true;
        return (
          `\n<div class=\"peer-modal-overlay\">\n  <div class=\"peer-modal\" role=\"dialog\" aria-modal=\"true\">\n    <button class=\"peer-modal-close\" id=\"eimClose\" aria-label=\"Close\">×</button>\n    <h3>Edit Interface</h3>\n    <form id=\"eimForm\" data-loading=\"${
            loading ? 1 : 0
          }\" autocomplete=\"off\" style=\"display:flex;flex-direction:column;gap:18px;\">\n      <div class=\"pm-field\">\n        <label for=\"eimName\">Name</label>\n        <input ${dis} class=\"${cls.trim()}\" id=\"eimName\" name=\"name\" value=\"${name}\" placeholder=\"e.g. wg0\" required maxlength=\"64\"/>\n      </div>\n      <div class=\"pm-field\">\n        <label for=\"eimPort\">Port</label>\n        <input ${dis} class=\"${cls.trim()}\" id=\"eimPort\" name=\"port\" value=\"${port}\" placeholder=\"51820\"/>\n      </div>\n      <div class=\"pm-field\">\n        <label for=\"eimNetwork\">Network</label>\n        <input ${dis} class=\"${cls.trim()}\" id=\"eimNetwork\" name=\"network\" value=\"${network}\" placeholder=\"10.0.0.0/24\"/>\n      </div>\n      <div class=\"pm-field\">\n        <label for=\"eimPublicIP\">Public IP</label>\n        <input ${dis} class=\"${cls.trim()}\" id=\"eimPublicIP\" name=\"public_ip\" value=\"${public_ip}\" placeholder=\"e.g. 203.0.113.10\"/>\n      </div>\n      <div class=\"pm-field\">\n        <label for=\"eimDNS\">DNS</label>\n        <input ${dis} class=\"${cls.trim()}\" id=\"eimDNS\" name=\"dns\" value=\"${dns}\" placeholder=\"e.g. 1.1.1.1\"/>\n      </div>` +
          // DNS service toggle (always shown; can be disabled while loading)
          `\n      <div class=\"pm-field\" style=\"flex-direction:row;align-items:center;gap:10px;\">\n        <label class=\"switch\" aria-label=\"Enable integrated DNS service\">\n          <input type=\"checkbox\" id=\"eimDnsService\" ${chkDis} ${
            dns_service ? "checked" : ""
          } />\n          <span class=\"slider\"></span>\n        </label>\n        <label for=\"eimDnsService\" style=\"margin:0;\">Enable integrated DNS service</label>\n        <span class=\"help-icon\" data-help=\"Integrated PyGuard DNS server. Resolves peer names to their IPs: peerName.interfaceName -> assigned peer IP (e.g. peer0.wg0 -> 10.0.0.2). Also resolves relay.interfaceName -> first IP in the interface network. Useful for easier hostnames inside the tunnel.\">?</span>\n      </div>` +
          (showFwd
            ? `\n      <div class=\"pm-field\" style=\"flex-direction:row;align-items:center;gap:10px;\">\n        <label class=\"switch\" aria-label=\"Forward traffic to Docker bridge\">\n          <input type=\"checkbox\" id=\"eimForwardDocker\" ${chkDis} ${
                forward_to_docker_bridge ? "checked" : ""
              } />\n          <span class=\"slider\"></span>\n        </label>\n        <label for=\"eimForwardDocker\" style=\"margin:0;\">Forward traffic to Docker bridge</label>\n        <span class=\"help-icon docker-help\" data-help=\"Adds NAT rules so traffic from peers destined to the interface relay name/IP goes to the container bridge allowing peers to access other services running outside this container on the host network.\">?</span>\n      </div>`
            : "") +
          `\n      <div class=\"pm-field\" style=\"flex-direction:row;align-items:center;gap:10px;\">\n        <label class=\"switch\" aria-label=\"Allow VPN gateway\">\n          <input type=\"checkbox\" id=\"eimAllowVpnGateway\" ${chkDis} ${
            allow_vpn_gateway ? "checked" : ""
          } />\n          <span class=\"slider\"></span>\n        </label>\n        <label for=\"eimAllowVpnGateway\" style=\"margin:0;\">Allow VPN gateway</label>\n        <span class=\"help-icon\" data-help=\"If enabled, peers can use this server as a gateway to reach external networks (e.g. the Internet) via proper AllowedIPs (like 0.0.0.0/0) and server-side NAT/forward rules. Disable if you want the VPN to be used only for intra-tunnel/private traffic.\">?</span>\n      </div>` +
          `\n      <div class=\"pm-field\" style=\"flex-direction:row;align-items:center;gap:10px;\">\n        <label class=\"switch\" aria-label=\"Ignore network range check\">\n          <input type=\"checkbox\" id=\"eimIgnore\" ${chkDis} checked />\n          <span class=\"slider\"></span>\n        </label>\n        <label for=\"eimIgnore\" style=\"margin:0;\">Ignore network range check</label>\n        <span class=\"help-icon\" data-help=\"Disables overlap checking for interface networks. Use only if you are sure overlapping CIDRs will not break routing.\">?</span>\n      </div>\n      <div id=\"eimFeedback\" style=\"font-size:12px; min-height:18px; color:#a0b4c0; white-space:pre-wrap; word-break:break-word;\"></div>\n      <div class=\"pm-actions\">\n        <button type=\"button\" id=\"eimCancel\" class=\"btn-danger btn-press\">Cancel</button>\n        <button type=\"submit\" id=\"eimValidate\" class=\"btn-glow\" style=\"min-width:150px;\">Apply</button>\n      </div>\n    </form>\n  </div>\n</div>`
        );
      }
      async function openEditInterfaceModal() {
        if (!currentInterface) {
          showToast("Select an interface first", false);
          return;
        }
        if (!editInterfaceModalMount) return;
        // show immediately (no loading fetch needed)
        editInterfaceModalMount.innerHTML = buildEditInterfaceModal({}, false);
        editInterfaceModalMount.style.display = "block";
        // Add DNS help tooltip next to the DNS field and adjust placeholder (explains special 'host')
        try {
          const dnsLabel = editInterfaceModalMount.querySelector(
            'label[for="eimDNS"]'
          );
          if (dnsLabel && !dnsLabel.querySelector(".help-icon")) {
            const span = document.createElement("span");
            span.className = "help-icon";
            span.textContent = "?";
            span.setAttribute(
              "data-help",
              "DNS server for peers and upstream DNS for pyguard-dns. Can be an IP (e.g. 1.1.1.1) or 'host'. 'host' means that depending on mode in which pyguard is running, it will either use the host's DNS (if running on bare metal), if integrated DNS service is enabled (see below) then the pyguard-dns will use DNS hosted on host (e.g. Pihole in another container), otherwise it will use public DNS by default 1.1.1.1;"
            );
            // Put the icon inside the label so it stays on the same line
            span.style.marginLeft = "6px";
            dnsLabel.appendChild(span);
          }
          const dnsInput = editInterfaceModalMount.querySelector("#eimDNS");
          if (
            dnsInput &&
            typeof dnsInput.placeholder === "string" &&
            !/\bhost\b/.test(dnsInput.placeholder)
          ) {
            dnsInput.placeholder = "e.g. 1.1.1.1 or host";
          }
        } catch (_) {}
        // Initialize help tooltips for newly injected content
        if (typeof initHelpTooltips === "function") {
          try {
            initHelpTooltips(editInterfaceModalMount);
          } catch (_) {}
        }
        const overlay = editInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = editInterfaceModalMount.querySelector("#eimClose");
        const btnCancel = editInterfaceModalMount.querySelector("#eimCancel");
        const form = editInterfaceModalMount.querySelector("#eimForm");
        const feedback = editInterfaceModalMount.querySelector("#eimFeedback");
        const nameInput = editInterfaceModalMount.querySelector("#eimName");
        const portInput = editInterfaceModalMount.querySelector("#eimPort");
        const networkInput =
          editInterfaceModalMount.querySelector("#eimNetwork");
        const publicIpInput =
          editInterfaceModalMount.querySelector("#eimPublicIP");
        const dnsInput = editInterfaceModalMount.querySelector("#eimDNS");
        const ignoreChk = editInterfaceModalMount.querySelector("#eimIgnore");
        function close() {
          editInterfaceModalMount.style.display = "none";
          editInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          // Build ValidateInterface payload (exclude dns and public_ip)
          const newName = (nameInput.value || "").trim();
          const newPortStr = (portInput.value || "").trim();
          const newNetwork = (networkInput.value || "").trim();
          const newPort = newPortStr
            ? parseInt(newPortStr, 10)
            : currentServer?.port ?? 0;
          const body = {
            interface: newName || currentInterface,
            port: Number.isFinite(newPort) ? newPort : currentServer?.port || 0,
            network: newNetwork || currentServer?.network || "",
            ignore_range_check: !!ignoreChk.checked,
            old_interface: currentInterface,
            old_port: currentServer?.port ?? null,
            old_network: currentServer?.network ?? null,
          };
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          try {
            const res = await fetch(`${apiBase}/interfaces/validate`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(body),
            });
            const text = await res.text();
            let json;
            try {
              json = JSON.parse(text);
            } catch {
              json = { raw: text };
            }
            if (!res.ok) {
              feedback.style.color = "#ff6b6b";
              feedback.textContent =
                typeof json === "object" && json?.detail
                  ? `Error: ${json.detail}`
                  : `Error: ${text}`;
              return;
            }
            feedback.style.color = "#9cf0b7";
            feedback.textContent = "Validated succesfuly";

            // On successful validation, apply changes via server/update
            const updBody = {
              // include only non-empty new values; backend compares against old_* to decide
              name:
                newName && newName !== currentInterface ? newName : undefined,
              port: Number.isFinite(newPort) ? newPort : undefined,
              network: newNetwork ? newNetwork : undefined,
              public_ip: (publicIpInput?.value || "").trim() || undefined,
              dns: (dnsInput?.value || "").trim() || undefined,
              forward_to_docker_bridge: (function () {
                const cb = form.querySelector("#eimForwardDocker");
                if (!cb) return undefined; // only send if present
                const cur = currentServer?.forward_to_docker_bridge ?? false;
                return cb.checked !== cur ? cb.checked : undefined;
              })(),
              dns_service: (function () {
                const cb = form.querySelector("#eimDnsService");
                if (!cb) return undefined;
                const cur =
                  currentServer?.["dns_service"] ??
                  currentServer?.dns_service ??
                  false;
                return cb.checked !== cur ? cb.checked : undefined;
              })(),
              allow_vpn_gateway: (function () {
                const cb = form.querySelector("#eimAllowVpnGateway");
                if (!cb) return undefined;
                const cur =
                  currentServer?.["allow_vpn_gateway"] ??
                  currentServer?.allow_vpn_gateway ??
                  false;
                return cb.checked !== cur ? cb.checked : undefined;
              })(),
              old_port: currentServer?.port ?? null,
              old_dns: currentServer?.dns ?? null,
              old_public_ip: currentServer?.public_ip ?? null,
              old_network: currentServer?.network ?? null,
              old_forward_to_docker_bridge:
                currentServer?.forward_to_docker_bridge ?? null,
              old_dns_service: (function () {
                const cur =
                  currentServer?.["dns_service"] ??
                  currentServer?.dns_service ??
                  null;
                return cur === null ? null : cur;
              })(),
              old_allow_vpn_gateway: (function () {
                const cur =
                  currentServer?.["allow_vpn_gateway"] ??
                  currentServer?.allow_vpn_gateway ??
                  null;
                return cur === null ? null : cur;
              })(),
            };
            feedback.style.color = "#32c861";
            feedback.textContent = "Validated. Applying changes...";
            try {
              const updRes = await fetch(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/server/update`,
                {
                  method: "POST",
                  headers: headers(),
                  body: JSON.stringify(updBody),
                }
              );
              const updPayload = await updRes.json().catch(() => ({}));
              if (!updRes.ok) {
                throw new Error(
                  updPayload?.detail || updRes.statusText || "Update failed"
                );
              }
              // Update interface list UI using returned list
              const list = Array.isArray(updPayload?.interfaces)
                ? updPayload.interfaces
                : [];
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              // Remove items no longer present
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
              // Determine final selected interface name (may have changed)
              const updatedName =
                updPayload?.interface || newName || currentInterface;
              currentInterface = updatedName;
              // Update selection highlight
              document
                .querySelectorAll(".iface-item")
                .forEach((i) =>
                  i.classList.toggle("active", i.dataset.name === updatedName)
                );
              // Update header and stats from new_data
              const nd = updPayload?.new_data || {};
              const s = nd.server || {};
              serverNetwork = s.network || "";
              if (typeof nd.forward_to_docker_bridge !== "undefined") {
                s.forward_to_docker_bridge = nd.forward_to_docker_bridge;
              }
              if (typeof nd["dns_service"] !== "undefined") {
                s["dns_service"] = nd["dns_service"];
              }
              if (typeof nd["allow_vpn_gateway"] !== "undefined") {
                s["allow_vpn_gateway"] = nd["allow_vpn_gateway"];
              }
              if (typeof nd["gateway_name"] !== "undefined") {
                window.PYGUARD_GATEWAY_NAME = nd["gateway_name"];
              }
              if (typeof updPayload.forward_to_docker_bridge !== "undefined") {
                s.forward_to_docker_bridge =
                  updPayload.forward_to_docker_bridge;
              }
              if (typeof updPayload["dns_service"] !== "undefined") {
                s["dns_service"] = updPayload["dns_service"];
              }
              if (typeof updPayload["allow_vpn_gateway"] !== "undefined") {
                s["allow_vpn_gateway"] = updPayload["allow_vpn_gateway"];
              }
              if (typeof updPayload["gateway_name"] !== "undefined") {
                window.PYGUARD_GATEWAY_NAME = updPayload["gateway_name"];
              }
              if (typeof nd.PYGUARD_IN_DOCKER !== "undefined") {
                window.PYGUARD_IN_DOCKER = nd.PYGUARD_IN_DOCKER ? 1 : 0;
                try {
                  const badge = document.getElementById("dockerModeBadge");
                  if (badge) {
                    if (window.PYGUARD_IN_DOCKER === 1) {
                      badge.style.display = "inline-block";
                    } else {
                      badge.style.display = "none";
                    }
                  }
                } catch (_) {}
              }
              currentServer = s;
              ifaceTitle.textContent = updatedName;
              // active pill
              const isActive = !!nd.active;
              if (ifaceActivePill) {
                ifaceActivePill.style.display = "inline-block";
                ifaceActivePill.classList.toggle("ok", isActive);
                ifaceActivePill.classList.toggle("bad", !isActive);
                ifaceActivePill.textContent = isActive ? "active" : "inactive";
                const nm =
                  currentInterface ||
                  updatedName ||
                  nd?.interface ||
                  "interface";
                ifaceActivePill.title = isActive
                  ? `Interface ${nm} is up and running`
                  : `Interface ${nm} is not turned on, bring it up by pressing enable button`;
                ifaceActivePill.setAttribute(
                  "data-help",
                  isActive
                    ? `Interface ${nm} is up and running`
                    : `Interface ${nm} is not turned on, bring it up by pressing enable button`
                );
                try {
                  if (
                    ifaceActivePill.matches(":hover") ||
                    document.activeElement === ifaceActivePill
                  ) {
                    ifaceActivePill.dispatchEvent(new Event("mouseenter"));
                  }
                } catch (_) {}
              }
              // Update feature pills after update
              (function updateFeaturePillsAfterUpdate() {
                const dnsOn = !!(s["dns_service"] ?? s.dns_service ?? false);
                const dockerOn = !!(s.forward_to_docker_bridge ?? false);
                const gwOn = !!(
                  s["allow_vpn_gateway"] ??
                  s.allow_vpn_gateway ??
                  false
                );
                if (ifaceDnsPill) {
                  ifaceDnsPill.style.display = "inline-block";
                  ifaceDnsPill.classList.toggle("on", dnsOn);
                  ifaceDnsPill.classList.toggle("off", !dnsOn);
                  ifaceDnsPill.classList.toggle("pill-dns", dnsOn);
                  ifaceDnsPill.textContent = "dns";
                  const dnsName = "DNS service";
                  const dnsMsg = dnsOn
                    ? `${dnsName} is active`
                    : `${dnsName} is disabled, check its usage in edit window`;
                  ifaceDnsPill.title = dnsMsg;
                  ifaceDnsPill.setAttribute("data-help", dnsMsg);
                  try {
                    if (
                      ifaceDnsPill.matches(":hover") ||
                      document.activeElement === ifaceDnsPill
                    ) {
                      ifaceDnsPill.dispatchEvent(new Event("mouseenter"));
                    }
                  } catch (_) {}
                }
                if (ifaceDockerPill) {
                  const inDocker =
                    window.PYGUARD_IN_DOCKER === 1 ||
                    window.PYGUARD_IN_DOCKER === true;
                  ifaceDockerPill.style.display = inDocker
                    ? "inline-block"
                    : "none";
                  if (inDocker) {
                    ifaceDockerPill.classList.toggle("on", dockerOn);
                    ifaceDockerPill.classList.toggle("off", !dockerOn);
                    ifaceDockerPill.textContent = "docker fwd";
                    const dockName = "Docker bridge forward";
                    const dockMsg = dockerOn
                      ? `${dockName} is active`
                      : `${dockName} is disabled, check its usage in edit window`;
                    ifaceDockerPill.title = dockMsg;
                    ifaceDockerPill.setAttribute("data-help", dockMsg);
                    try {
                      if (
                        ifaceDockerPill.matches(":hover") ||
                        document.activeElement === ifaceDockerPill
                      ) {
                        ifaceDockerPill.dispatchEvent(new Event("mouseenter"));
                      }
                    } catch (_) {}
                  }
                }
                if (ifaceGatewayPill) {
                  ifaceGatewayPill.style.display = "inline-block";
                  ifaceGatewayPill.classList.toggle("on", gwOn);
                  ifaceGatewayPill.classList.toggle("off", !gwOn);
                  ifaceGatewayPill.textContent = "vpn gateway";
                  const gwName = "VPN gateway";
                  const gwMsg = gwOn
                    ? `${gwName} is active`
                    : `${gwName} is disabled, check its usage in edit window`;
                  ifaceGatewayPill.title = gwMsg;
                  ifaceGatewayPill.setAttribute("data-help", gwMsg);
                  try {
                    if (
                      ifaceGatewayPill.matches(":hover") ||
                      document.activeElement === ifaceGatewayPill
                    ) {
                      ifaceGatewayPill.dispatchEvent(new Event("mouseenter"));
                    }
                  } catch (_) {}
                }
              })();
              try {
                const enableBtn = document.getElementById("btnEnableService");
                if (enableBtn) {
                  if (!isActive) enableBtn.classList.add("btn-enable-pulse");
                  else enableBtn.classList.remove("btn-enable-pulse");
                }
              } catch (_) {}
              // stats
              const peerCount =
                nd.peer_count ?? (nd.peers ? Object.keys(nd.peers).length : 0);
              const stats = [
                { label: "Network", value: s.network || "-" },
                { label: "relay ip", value: s.ip || "—" },
                { label: "Port", value: s.port || "-" },
                { label: "Peers", value: peerCount },
                { label: "Public IP", value: s.public_ip || "—" },
              ];
              ifaceMeta.innerHTML = stats
                .map(
                  (st) =>
                    `<div class="iface-stat"><span class="label">${st.label}</span><span>${st.value}</span></div>`
                )
                .join("");
              // peers list from new_data
              let peersData = nd.peers || {};
              if (typeof peersData === "string") {
                try {
                  const parsed = JSON.parse(peersData);
                  peersData = parsed?.peers || parsed || {};
                } catch {
                  peersData = {};
                }
              }
              const names = Object.keys(peersData);
              peers = names.map((n) => {
                const info = peersData[n] || {};
                return {
                  public_key: info.public_key || n,
                  name: n,
                  active: !!info.active,
                  last_handshake: info.last_handshake || null,
                  last_handshake_str: info.last_handshake_str || "",
                  download: info.download || "0 KiB",
                  uploaded: info.uploaded || "0 KiB",
                };
              });
              renderPeerList();
              // Keep island expanded (no peer open) after server update
              islandEl.classList.add("expanded");
              islandEl
                .querySelector(".details-region")
                ?.classList.remove("peer-open");
              hidePeerDetailPanel();
              emptyState.style.display = "block";
              // Determine if backend reports an actual change
              const changed = !!updPayload?.something_changed;
              const applyBtn = form.querySelector("#eimValidate");
              if (changed) {
                // Close modal then show success + guidance
                close();
                showToast("Server updated");
                const finalPort =
                  currentServer?.port || s.port || updPayload?.port;
                showInterfaceSuccess("edited", currentInterface, finalPort);

                // Re-initialize tooltips after update
                if (typeof initHelpTooltips === "function") {
                  try {
                    setTimeout(() => initHelpTooltips(document), 100);
                  } catch (_) {}
                }
              } else {
                // Keep modal open; inform user nothing changed and reflect via button label
                showToast("No changes detected");
                feedback.style.color = "#a0b4c0";
                feedback.textContent = "No changes to apply.";
                if (applyBtn) {
                  const originalText = applyBtn.textContent;
                  applyBtn.textContent = "Nothing changed";
                  applyBtn.disabled = true;
                  // Revert after short delay so user can attempt edits
                  setTimeout(() => {
                    if (!document.body.contains(applyBtn)) return;
                    applyBtn.textContent = originalText;
                    applyBtn.disabled = false;
                  }, 2000);
                }
              }
            } catch (err) {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = `Update failed: ${
                err?.message || "error"
              }`;
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err?.message || "validation failed"
            }`;
          }
        });
      }
      if (btnServerSettings) btnServerSettings.onclick = openEditInterfaceModal;
      if (btnCancelEdit)
        btnCancelEdit.onclick = () => {
          if (originalPeerData) openPeer(currentPeerPublicKey);
        };
      // Add Interface modal
      function buildAddInterfaceModal(prefill, loading = false) {
        const name = prefill?.name || "";
        const port = prefill?.port ?? "";
        const network = prefill?.network || "";
        const public_ip = prefill?.public_ip || "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        const chkDis = loading ? "disabled" : "";
        const showFwd =
          window.PYGUARD_IN_DOCKER === 1 || window.PYGUARD_IN_DOCKER === true;
        return (
          `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="aimClose" aria-label="Close">×</button>\n    <h3>Add Interface</h3>\n    <form id="aimForm" data-loading="${
            loading ? 1 : 0
          }" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="aimName">Name</label>\n        <input ${dis} class="${cls.trim()}" id="aimName" name="name" value="${name}" placeholder="e.g. wg0" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimPort">Port</label>\n        <input ${dis} class="${cls.trim()}" id="aimPort" name="port" value="${port}" placeholder="51820"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimNetwork">Network</label>\n        <input ${dis} class="${cls.trim()}" id="aimNetwork" name="network" value="${network}" placeholder="10.0.0.0/24"/>\n      </div>\n      <div class="pm-field">\n        <label for="aimPublicIP">Public IP</label>\n        <input ${dis} class="${cls.trim()}" id="aimPublicIP" name="public_ip" value="${public_ip}" placeholder="e.g. 203.0.113.10"/>\n      </div>` +
          // DNS service toggle (switch)
          `\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <label class="switch" aria-label="Enable integrated DNS service">\n          <input type="checkbox" id="aimDnsService" ${chkDis} />\n          <span class="slider"></span>\n        </label>\n        <label for="aimDnsService" style="margin:0;">Enable integrated DNS service</label>\n        <span class="help-icon" data-help="Integrated PyGuard DNS server. Resolves peer names to their IPs: peerName.interfaceName -> assigned peer IP (e.g. peer0.wg0 -> 10.0.0.2). Also resolves relay.interfaceName -> first IP in the interface network. Useful for easier hostnames inside the tunnel.">?</span>\n      </div>` +
          // Forward to docker bridge (Docker mode only)
          (showFwd
            ? `\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <label class="switch" aria-label="Forward traffic to Docker bridge">\n          <input type="checkbox" id="aimForwardDocker" ${chkDis} />\n          <span class="slider"></span>\n        </label>\n        <label for="aimForwardDocker" style="margin:0;">Forward traffic to Docker bridge</label>\n        <span class="help-icon docker-help" data-help="Adds NAT rules so traffic from peers destined to the interface relay name/IP goes to the container bridge allowing peers to access other services running outside this container on the host network.">?</span>\n      </div>`
            : "") +
          // Allow VPN gateway (switch)
          `\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <label class="switch" aria-label="Allow VPN gateway">\n          <input type="checkbox" id="aimAllowVpnGateway" ${chkDis} />\n          <span class="slider"></span>\n        </label>\n        <label for="aimAllowVpnGateway" style="margin:0;">Allow VPN gateway</label>\n        <span class="help-icon" data-help="If enabled, peers can use this server as a gateway to reach external networks (e.g. the Internet) via proper AllowedIPs (like 0.0.0.0/0) and server-side NAT/forward rules. Disable if you want the VPN to be used only for intra-tunnel/private traffic.">?</span>\n      </div>` +
          // Ignore range check (switch)
          `\n      <div class="pm-field" style="flex-direction:row;align-items:center;gap:10px;">\n        <label class="switch" aria-label="Ignore network range check">\n          <input type="checkbox" id="aimIgnore" ${chkDis} checked />\n          <span class="slider"></span>\n        </label>\n        <label for="aimIgnore" style="margin:0;">Ignore network range check</label>\n        <span class="help-icon" data-help="Disables overlap checking for interface networks. Use only if you are sure overlapping CIDRs will not break routing.">?</span>\n      </div>\n      <div id="aimFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="aimCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="aimCreate" class="btn-glow">Create</button>\n      </div>\n    </form>\n  </div>\n</div>`
        );
      }
      async function openAddInterfaceModal() {
        if (!addInterfaceModalMount) return;
        // Render instantly in loading state
        addInterfaceModalMount.innerHTML = buildAddInterfaceModal({}, true);
        addInterfaceModalMount.style.display = "block";
        const overlay = addInterfaceModalMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = addInterfaceModalMount.querySelector("#aimClose");
        const btnCancel = addInterfaceModalMount.querySelector("#aimCancel");
        const form = addInterfaceModalMount.querySelector("#aimForm");
        const feedback = addInterfaceModalMount.querySelector("#aimFeedback");
        const nameInput = addInterfaceModalMount.querySelector("#aimName");
        // Initialize tooltips for help icons in the modal
        if (typeof initHelpTooltips === "function") {
          try {
            initHelpTooltips(addInterfaceModalMount);
          } catch (_) {}
        }
        function close() {
          addInterfaceModalMount.style.display = "none";
          addInterfaceModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        let isLoading = true;
        // Kick off async fetch of defaults; populate and unlock when ready
        (async () => {
          let defaults = {};
          try {
            defaults =
              (await fetchJSON(`${apiBase}/interfaces/defaults`, {
                headers: headers(),
              })) || {};
          } catch (_) {
            defaults = {};
          }
          // Update values
          const _name = addInterfaceModalMount.querySelector("#aimName");
          const _port = addInterfaceModalMount.querySelector("#aimPort");
          const _net = addInterfaceModalMount.querySelector("#aimNetwork");
          const _pip = addInterfaceModalMount.querySelector("#aimPublicIP");
          if (_name && !_name.value) _name.value = defaults.name || "";
          if (_port && !_port.value) _port.value = defaults.port ?? "";
          if (_net && !_net.value) _net.value = defaults.network || "";
          if (_pip && !_pip.value) _pip.value = defaults.public_ip || "";
          // Unlock inputs
          [_name, _port, _net, _pip].forEach((el) => {
            if (el) {
              el.removeAttribute("disabled");
              el.classList.remove("input-loading");
              el.removeAttribute("aria-busy");
            }
          });
          const chk = addInterfaceModalMount.querySelector("#aimIgnore");
          if (chk) chk.removeAttribute("disabled");
          const chkDns = addInterfaceModalMount.querySelector("#aimDnsService");
          if (chkDns) chkDns.removeAttribute("disabled");
          const chkFwd =
            addInterfaceModalMount.querySelector("#aimForwardDocker");
          if (chkFwd) chkFwd.removeAttribute("disabled");
          const chkGw = addInterfaceModalMount.querySelector(
            "#aimAllowVpnGateway"
          );
          if (chkGw) chkGw.removeAttribute("disabled");
          isLoading = false;
          form?.setAttribute("data-loading", "0");
          // Now focus the name field
          _name?.focus();
          // Re-init tooltips after unlocking to ensure size is measured correctly
          if (typeof initHelpTooltips === "function") {
            try {
              initHelpTooltips(addInterfaceModalMount);
            } catch (_) {}
          }
        })();
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (form?.getAttribute("data-loading") === "1") {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Please wait for defaults...";
            return;
          }
          const name = (
            addInterfaceModalMount.querySelector("#aimName")?.value || ""
          ).trim();
          const portStr = (
            addInterfaceModalMount.querySelector("#aimPort")?.value || ""
          ).trim();
          const network = (
            addInterfaceModalMount.querySelector("#aimNetwork")?.value || ""
          ).trim();
          const public_ip = (
            addInterfaceModalMount.querySelector("#aimPublicIP")?.value || ""
          ).trim();
          const enable_dns_service =
            !!addInterfaceModalMount.querySelector("#aimDnsService")?.checked;
          const allow_vpn_gateway = !!addInterfaceModalMount.querySelector(
            "#aimAllowVpnGateway"
          )?.checked;
          const forward_to_docker_bridge =
            !!addInterfaceModalMount.querySelector("#aimForwardDocker")
              ?.checked;
          const ignore =
            !!addInterfaceModalMount.querySelector("#aimIgnore")?.checked;
          const port = parseInt(portStr, 10);
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name is required";
            return;
          }
          if (!Number.isFinite(port)) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Port is required";
            return;
          }
          if (!network) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Network is required";
            return;
          }
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          try {
            const validateBody = {
              interface: name,
              port,
              network,
              ignore_range_check: ignore,
            };
            const v = await fetchJSON(`${apiBase}/interfaces/validate`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(validateBody),
            });
            if (!v || !v.ok) {
              throw new Error(v?.detail || "Validation failed");
            }
            feedback.style.color = "#32c861";
            feedback.textContent = "Validated. Creating...";
            const createBody = { interface: name, port, network };
            if (public_ip) createBody.public_ip = public_ip;
            // New flags
            createBody.enable_dns_service = enable_dns_service;
            createBody.allow_vpn_gateway = allow_vpn_gateway;
            if (
              addInterfaceModalMount.querySelector("#aimForwardDocker") !== null
            ) {
              createBody.forward_to_docker_bridge = !!forward_to_docker_bridge;
            }
            const res = await fetchJSON(`${apiBase}/interfaces/add`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify(createBody),
            });
            // Update interface list from returned data
            const list = Array.isArray(res?.interfaces) ? res.interfaces : [];
            if (list.length) {
              const desired = list
                .map((obj) => ({
                  name: obj && typeof obj === "object" ? obj.name : obj,
                  active: obj && typeof obj === "object" ? !!obj.active : false,
                }))
                .filter((x) => !!x.name);
              const existing = new Map();
              Array.from(
                interfacesContainer.querySelectorAll(".iface-item")
              ).forEach((el) => {
                const n = el.dataset.name;
                if (n) existing.set(n, el);
              });
              existing.forEach((el, n) => {
                if (!desired.find((d) => d.name === n)) {
                  el.remove();
                  existing.delete(n);
                }
              });
              desired.forEach(({ name, active }) => {
                let el = existing.get(name);
                if (!el) {
                  el = document.createElement("div");
                  el.className = "iface-item";
                  el.dataset.name = name;
                  el.onclick = () => selectInterface(name);
                  el.innerHTML = `<span class="iface-name"></span><span class="iface-pill status-pill small"></span>`;
                  existing.set(name, el);
                }
                el.classList.toggle("active", name === currentInterface);
                const nameSpan = el.querySelector(".iface-name");
                if (nameSpan && nameSpan.textContent !== name)
                  nameSpan.textContent = name;
                const pill = el.querySelector(".iface-pill");
                if (pill) {
                  pill.classList.toggle("ok", !!active);
                  pill.classList.toggle("bad", !active);
                  pill.textContent = active ? "active" : "inactive";
                  pill.title = active ? "Active" : "Inactive";
                }
              });
              desired.forEach(({ name }) => {
                const el = existing.get(name);
                if (el) interfacesContainer.appendChild(el);
              });
            } else {
              await loadInterfaces();
            }
            close();
            showToast("Interface created");
            // Select the newly created interface
            await selectInterface(name);
            // After selection, display guidance modal
            showInterfaceSuccess("created", name, port);
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${err.message || "Creation failed"}`;
          }
        });
      }
      // Tooltip system for help icons
      let helpTooltipEl = null;
      function ensureHelpTooltip() {
        if (!helpTooltipEl) {
          helpTooltipEl = document.createElement("div");
          helpTooltipEl.className = "help-tooltip";
          document.body.appendChild(helpTooltipEl);
        }
        return helpTooltipEl;
      }
      function positionHelpTooltip(target) {
        const tt = ensureHelpTooltip();
        const rect = target.getBoundingClientRect();
        const margin = 8;
        const top = rect.top + window.scrollY - tt.offsetHeight - margin;
        let left =
          rect.left + window.scrollX + rect.width / 2 - tt.offsetWidth / 2;
        const vw = window.innerWidth;
        if (left < 8) left = 8;
        if (left + tt.offsetWidth + 8 > vw) left = vw - tt.offsetWidth - 8;
        tt.style.top =
          (top < 8 ? rect.bottom + window.scrollY + margin : top) + "px";
        tt.style.left = left + "px";
      }
      function initHelpTooltips(scope) {
        const icons = scope.querySelectorAll(".help-icon");
        icons.forEach((icon) => {
          icon.addEventListener("mouseenter", () => {
            const msg = icon.getAttribute("data-help");
            if (!msg) return;
            const tt = ensureHelpTooltip();
            tt.textContent = msg;
            tt.classList.add("visible");
            // Temporarily set for measurement
            tt.style.top = "0px";
            tt.style.left = "0px";
            requestAnimationFrame(() => positionHelpTooltip(icon));
          });
          icon.addEventListener("mouseleave", () => {
            if (helpTooltipEl) helpTooltipEl.classList.remove("visible");
          });
          icon.addEventListener("focus", () =>
            icon.dispatchEvent(new Event("mouseenter"))
          );
          icon.addEventListener("blur", () =>
            icon.dispatchEvent(new Event("mouseleave"))
          );
        });

        // Also initialize tooltips for status pills with data-help
        const pills = scope.querySelectorAll(".status-pill[data-help]");
        pills.forEach((pill) => {
          pill.addEventListener("mouseenter", () => {
            const msg = pill.getAttribute("data-help");
            if (!msg) return;
            const tt = ensureHelpTooltip();
            tt.textContent = msg;
            tt.classList.add("visible");
            // Temporarily set for measurement
            tt.style.top = "0px";
            tt.style.left = "0px";
            requestAnimationFrame(() => positionHelpTooltip(pill));
          });
          pill.addEventListener("mouseleave", () => {
            if (helpTooltipEl) helpTooltipEl.classList.remove("visible");
          });
          pill.addEventListener("focus", () =>
            pill.dispatchEvent(new Event("mouseenter"))
          );
          pill.addEventListener("blur", () =>
            pill.dispatchEvent(new Event("mouseleave"))
          );
        });
      }
      if (btnOpenAddInterface)
        btnOpenAddInterface.addEventListener("click", openAddInterfaceModal);
      // QR + Edit peer actions
      function showQrModal(peerName) {
        if (!currentInterface || !peerName) {
          showToast("No peer selected", false);
          return;
        }
        qrPeerModalMount.innerHTML = `<div class="peer-modal-overlay"><div class="peer-modal" style="width:460px;" role="dialog" aria-modal="true"><button class="peer-modal-close" id="qrClose">×</button><h3 style="margin-top:0;">QR Code - ${peerName}</h3><div id="qrContent" style="display:flex;justify-content:center;align-items:center;min-height:240px;">Loading...</div><div class="pm-actions" style="justify-content:flex-end;"><button class="btn-danger" type="button" id="qrDismiss">Close</button></div></div></div>`;
        qrPeerModalMount.style.display = "block";
        const overlay = qrPeerModalMount.querySelector(".peer-modal-overlay");
        const closeBtn = qrPeerModalMount.querySelector("#qrClose");
        const dismiss = qrPeerModalMount.querySelector("#qrDismiss");
        const content = qrPeerModalMount.querySelector("#qrContent");
        function close() {
          qrPeerModalMount.style.display = "none";
          qrPeerModalMount.innerHTML = "";
        }
        closeBtn.onclick = close;
        dismiss.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        fetchJSON(
          `${apiBase}/interfaces/${encodeURIComponent(
            currentInterface
          )}/peers/${encodeURIComponent(peerName)}/qr`,
          { headers: headers() }
        )
          .then((d) => {
            if (!d || !d.qr_png_base64) {
              content.textContent = "Failed fetching QR";
              return;
            }
            // Display QR at roughly 2x size (while preserving crisp modules)
            content.innerHTML = `<img alt="QR for ${peerName}" style="image-rendering:pixelated;border:1px solid #22323f;padding:12px;background:#0f181f;border-radius:16px;max-width:none;width:360px;height:360px;" src="data:image/png;base64,${d.qr_png_base64}">`;
          })
          .catch(() => {
            content.textContent = "Failed fetching QR";
          });
      }
      if (btnQrPeer)
        btnQrPeer.addEventListener("click", () => {
          const name =
            peerDetailTitle &&
            peerDetailTitle.dataset &&
            peerDetailTitle.dataset.peerName
              ? peerDetailTitle.dataset.peerName
              : currentPeerName ||
                (peerDetailTitle ? peerDetailTitle.textContent.trim() : "");
          if (!name || name === "Peer") {
            showToast("Select a peer first", false);
            return;
          }
          showQrModal(name);
        });
      // Edit Peer modal
      function buildEditPeerModal(prefill, loading = false) {
        const n = prefill?.name || "";
        const ip = prefill?.ip || "";
        const allowed = prefill?.allowed_ips || "";
        const dis = loading ? 'disabled aria-busy="true"' : "";
        const cls = loading ? " input-loading" : "";
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="epmClose" aria-label="Close">×</button>\n    <h3>Edit Peer</h3>\n    <form id="epmForm" data-loading="${
          loading ? 1 : 0
        }" autocomplete="off" style="display:flex;flex-direction:column;gap:18px;">\n      <div class="pm-field">\n        <label for="epmName">Peer Name</label>\n        <input ${dis} class="${cls.trim()}" id="epmName" name="name" value="${n}" placeholder="peer name" required maxlength="64"/>\n      </div>\n      <div class="pm-field">\n        <label for="epmIP">Peer IP</label>\n        <input ${dis} class="${cls.trim()}" id="epmIP" name="ip" value="${ip}" placeholder="e.g. 10.0.0.2/32"/>\n      </div>\n      <div class="pm-field">\n        <label for="epmAllowed">Allowed IPs</label>\n        <input ${dis} class="${cls.trim()}" id="epmAllowed" name="allowed_ips" value="${allowed}" placeholder="e.g. 0.0.0.0/0, ::/0"/>\n      </div>\n      <div id="epmFeedback" style="font-size:12px; min-height:18px; color:#a0b4c0;"></div>\n      <div class="pm-actions">\n        <button type="button" id="epmCancel" class="btn-danger btn-press">Cancel</button>\n        <button type="submit" id="epmApply" class="btn-glow">Apply</button>\n      </div>\n    </form>\n  </div>\n</div>`;
      }
      async function openEditPeerModal() {
        if (!currentInterface || !currentPeerName) {
          showToast("Select a peer first", false);
          return;
        }
        // Open instantly in loading state
        editPeerModalMount.innerHTML = buildEditPeerModal({}, true);
        editPeerModalMount.style.display = "block";
        const overlay = editPeerModalMount.querySelector(".peer-modal-overlay");
        const form = editPeerModalMount.querySelector("#epmForm");
        const btnCancel = editPeerModalMount.querySelector("#epmCancel");
        const btnClose = editPeerModalMount.querySelector("#epmClose");
        const feedback = editPeerModalMount.querySelector("#epmFeedback");
        const nameInput = editPeerModalMount.querySelector("#epmName");
        const ipInput = editPeerModalMount.querySelector("#epmIP");
        const allowedInput = editPeerModalMount.querySelector("#epmAllowed");
        function close() {
          editPeerModalMount.style.display = "none";
          editPeerModalMount.innerHTML = "";
        }
        btnCancel.onclick = close;
        btnClose.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        // Populate and unlock asynchronously (use existing detail if available, otherwise fetch)
        (async () => {
          let ip = lastPeerDetail?.peer_data?.ip || "";
          let allowed = lastPeerDetail?.peer_data?.allowed_ips || "";
          if (!ip || !allowed) {
            try {
              const d = await fetchJSON(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/peers/${encodeURIComponent(currentPeerName)}`,
                { headers: headers() }
              );
              ip = d?.peer_data?.ip || ip || "";
              allowed = d?.peer_data?.allowed_ips || allowed || "";
            } catch (_) {}
          }
          // Fill fields
          if (nameInput) nameInput.value = currentPeerName;
          if (ipInput) ipInput.value = ip;
          if (allowedInput) allowedInput.value = allowed;
          // Unlock
          [nameInput, ipInput, allowedInput].forEach((el) => {
            if (el) {
              el.removeAttribute("disabled");
              el.classList.remove("input-loading");
              el.removeAttribute("aria-busy");
            }
          });
          form?.setAttribute("data-loading", "0");
          nameInput?.focus();
        })();
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          feedback.style.color = "#a0b4c0";
          feedback.textContent = "Validating...";
          const name = nameInput.value.trim();
          const ipVal =
            ipInput.value.trim() || lastPeerDetail?.peer_data?.ip || "";
          const newAllowed = allowedInput.value.trim();
          if (form?.getAttribute("data-loading") === "1") {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Please wait for current values...";
            return;
          }
          if (!name) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = "Name required";
            return;
          }
          const payload = {
            name,
            ip: ipVal || null,
            old_name: currentPeerName,
            old_ip: lastPeerDetail?.peer_data?.ip || null,
            new_allowed: newAllowed || null,
            old_allowed: lastPeerDetail?.peer_data?.allowed_ips || null,
          };
          try {
            const res = await fetchJSON(
              `${apiBase}/interfaces/${encodeURIComponent(
                currentInterface
              )}/peers/validate`,
              {
                method: "POST",
                headers: headers(),
                body: JSON.stringify(payload),
              }
            );
            if (res && res.ok) {
              feedback.style.color = "#32c861";
              feedback.textContent = "Validated. Applying changes...";
              // Build patch body based on differences
              const patchBody = {};
              if (
                newAllowed &&
                newAllowed !== (lastPeerDetail?.peer_data?.allowed_ips || "")
              )
                patchBody.allowed_ips = newAllowed;
              if (ipVal && ipVal !== (lastPeerDetail?.peer_data?.ip || ""))
                patchBody.ip = ipVal;
              if (name && name !== currentPeerName) patchBody.new_name = name;
              if (Object.keys(patchBody).length === 0) {
                feedback.textContent = "Nothing to change";
                return;
              }
              const upd = await fetchJSON(
                `${apiBase}/interfaces/${encodeURIComponent(
                  currentInterface
                )}/peers/${encodeURIComponent(currentPeerName)}/update`,
                {
                  method: "POST",
                  headers: headers(),
                  body: JSON.stringify(patchBody),
                }
              );
              // Update peers list from returned interface summary
              const iface = upd?.interface || {};
              let peersData = iface.peers || {};
              if (typeof peersData === "string") {
                try {
                  const parsed = JSON.parse(peersData);
                  peersData = parsed?.peers || parsed || {};
                } catch {
                  peersData = {};
                }
              }
              const names = Object.keys(peersData);
              peers = names.map((n) => {
                const info = peersData[n] || {};
                return {
                  public_key: info.public_key || n,
                  name: n,
                  active: !!info.active,
                  last_handshake: info.last_handshake || null,
                  last_handshake_str: info.last_handshake_str || "",
                  download: info.download || "0 KiB",
                  uploaded: info.uploaded || "0 KiB",
                };
              });
              renderPeerList();
              // Select corrected/renamed peer and populate detail
              const finalName = upd?.name || name;
              const selected = peers.find((p) => p.name === finalName);
              close();
              showToast("Peer updated");
              if (selected) {
                openPeer(selected.public_key || selected.name);
              }
            } else {
              feedback.style.color = "#ff6b6b";
              feedback.textContent = (res && res.detail) || "Validation failed";
            }
          } catch (err) {
            feedback.style.color = "#ff6b6b";
            feedback.textContent = `Error: ${
              err.message || "Validation error"
            }`;
          }
        });
      }
      if (btnEditPeer) btnEditPeer.addEventListener("click", openEditPeerModal);
      btnRefresh.onclick = async () => {
        await loadInterfaceAll();
        showToast("Refreshed");
      };
      peerSearch.addEventListener("input", renderPeerList);
      (async () => {
        await loadInterfaces(); /* No auto-select; user must click an interface to expand */
        // Start periodic refresh of interface list every 5s
        clearInterfacesListInterval();
        interfacesListInterval = setInterval(() => {
          try {
            loadInterfaces();
          } catch (_) {}
        }, 5000);

        // Initialize tooltips on page load
        if (typeof initHelpTooltips === "function") {
          try {
            initHelpTooltips(document);
          } catch (_) {}
        }
      })();
      // Clicking the top-left PyGuard logo/title resets selection to initial state
      function resetToInitialState() {
        clearPeerDetailInterval();
        clearInterfaceRefreshInterval();
        // Remove any active states
        document
          .querySelectorAll(".peer-row.active")
          .forEach((el) => el.classList.remove("active"));
        document
          .querySelectorAll(".iface-item")
          .forEach((el) => el.classList.remove("active"));
        const detailsRegion = islandEl.querySelector(".details-region");
        if (detailsRegion) detailsRegion.classList.remove("peer-open");
        islandEl.classList.remove("peer-open");
        islandEl.classList.remove("expanded");
        hidePeerDetailPanel();
        // Clear UI texts
        const ifaceTitleEl = document.getElementById("ifaceTitle");
        const ifaceMetaEl = document.getElementById("ifaceStats");
        const peersContainerEl = document.getElementById("peersContainer");
        if (ifaceTitleEl) ifaceTitleEl.textContent = "Select an interface";
        if (ifaceMetaEl) ifaceMetaEl.innerHTML = "";
        if (peersContainerEl) peersContainerEl.innerHTML = "";
        const pill = document.getElementById("ifaceActivePill");
        if (pill) pill.style.display = "none";
        const dnsP = document.getElementById("ifaceDnsPill");
        if (dnsP) dnsP.style.display = "none";
        const dockP = document.getElementById("ifaceDockerPill");
        if (dockP) dockP.style.display = "none";
        const gwP = document.getElementById("ifaceGatewayPill");
        if (gwP) gwP.style.display = "none";
        const currentLabel = document.getElementById("current-interface-label");
        if (currentLabel) currentLabel.textContent = "";
        // Reset state
        currentPeerPublicKey = null;
        currentPeerName = null;
        lastPeerDetail = null;
        currentInterface = null;
        // Ensure empty state message is visible in peers panel
        const emptyStateEl = document.getElementById("emptyState");
        if (emptyStateEl) emptyStateEl.style.display = "block";
      }
      if (logoTitle) {
        logoTitle.style.cursor = "pointer";
        logoTitle.addEventListener("click", resetToInitialState);
      }
      // Logout confirmation (styled modal)
      const logoutLink = document.querySelector(".logout");
      const logoutModalMount = document.getElementById("logoutModal");
      function buildLogoutModal() {
        return `\n<div class="peer-modal-overlay">\n  <div class="peer-modal" role="dialog" aria-modal="true">\n    <button class="peer-modal-close" id="lomClose" aria-label="Close">×</button>\n    <h3>Logout</h3>\n    <div style="font-size:14px;color:#cfd8dc;">Are you sure you want to log out?</div>\n    <div class="pm-actions">\n      <button type="button" id="lomCancel" class="btn-press">Cancel</button>\n      <button type="button" id="lomLogout" class="btn-danger btn-press">Logout</button>\n    </div>\n  </div>\n</div>`;
      }
      function openLogoutModal(anchor) {
        logoutModalMount.innerHTML = buildLogoutModal();
        logoutModalMount.style.display = "block";
        const overlay = logoutModalMount.querySelector(".peer-modal-overlay");
        const btnClose = logoutModalMount.querySelector("#lomClose");
        const btnCancel = logoutModalMount.querySelector("#lomCancel");
        const btnLogout = logoutModalMount.querySelector("#lomLogout");
        function close() {
          logoutModalMount.style.display = "none";
          logoutModalMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnCancel.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        btnLogout.onclick = async () => {
          await fetch("/logout", { method: "POST" }).then(() => {
            window.location.href = "/login";
          });
        };
      }
      if (logoutLink) {
        logoutLink.addEventListener("click", (e) => {
          e.preventDefault();
          openLogoutModal(logoutLink);
        });
      }

      // Reusable Interface Success / Guidance Modal
      const interfaceSuccessMount = document.getElementById(
        "interfaceSuccessModal"
      );
      const settingsModalMount = document.getElementById("settingsModal");
      const btnOpenSettings = document.getElementById("btnOpenSettings");
      function buildSettingsModal(activeCat = "password") {
        return `\n<div class=\"peer-modal-overlay\">\n  <div class=\"settings-modal\" role=\"dialog\" aria-modal=\"true\">\n    <button class=\"settings-close-btn\" id=\"settingsClose\" aria-label=\"Close\">×</button>\n    <div class=\"settings-left\">\n      <h4>Settings</h4>\n      <ul class=\"settings-nav\">\n        <li data-cat=\"password\" class=\"${
          activeCat === "password" ? "active" : ""
        }\">Change Password</li>\n      </ul>\n    </div>\n    <div class=\"settings-content\" id=\"settingsContent\">\n      ${renderSettingContent(
          activeCat
        )}\n    </div>\n  </div>\n</div>`;
      }
      function renderSettingContent(cat) {
        if (cat === "password") {
          return `<div id=\"passwordSetting\">\n  <h3>Change Password</h3>\n  <p style=\"margin:0;font-size:13px;color:#90a4ae;line-height:1.5;\">Update the administrative password. After changing, sessions may require re-authentication.</p>\n  <form id=\"cpForm\" class=\"settings-form\" autocomplete=\"off\">\n    <div class=\"settings-field\">\n      <label for=\"cpOld\">Current Password</label>\n      <input id=\"cpOld\" name=\"old_password\" type=\"password\" required autocomplete=\"current-password\" />\n    </div>\n    <div class=\"settings-field\">\n      <label for=\"cpNew1\">New Password</label>\n      <input id=\"cpNew1\" name=\"new_password1\" type=\"password\" required autocomplete=\"new-password\" />\n    </div>\n    <div class=\"settings-field\">\n      <label for=\"cpNew2\">Confirm New Password</label>\n      <input id=\"cpNew2\" name=\"new_password2\" type=\"password\" required autocomplete=\"new-password\" />\n    </div>\n    <div id=\"cpFeedback\"></div>\n    <div style=\"display:flex; gap:12px; justify-content:flex-end;\">\n      <button type=\"button\" id=\"cpCancel\" class=\"btn-danger btn-press\">Cancel</button>\n      <button type=\"submit\" id=\"cpSubmit\" class=\"btn-glow\">Change</button>\n    </div>\n  </form>\n</div>`;
        }
        return `<div><h3>Unknown</h3><p style=\"font-size:13px;color:#90a4ae;\">Category not found.</p></div>`;
      }
      function openSettingsModal(cat = "password") {
        if (!settingsModalMount) return;
        settingsModalMount.innerHTML = buildSettingsModal(cat);
        settingsModalMount.style.display = "block";
        const overlay = settingsModalMount.querySelector(".peer-modal-overlay");
        const closeBtn = settingsModalMount.querySelector("#settingsClose");
        const navItems =
          settingsModalMount.querySelectorAll(".settings-nav li");
        const content = settingsModalMount.querySelector("#settingsContent");
        function close() {
          settingsModalMount.style.display = "none";
          settingsModalMount.innerHTML = "";
        }
        closeBtn.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
        navItems.forEach((li) =>
          li.addEventListener("click", () => {
            navItems.forEach((n) => n.classList.remove("active"));
            li.classList.add("active");
            const c = li.getAttribute("data-cat");
            content.innerHTML = renderSettingContent(c);
            wirePasswordForm();
          })
        );
        wirePasswordForm();
      }
      function wirePasswordForm() {
        const form = settingsModalMount.querySelector("#cpForm");
        if (!form) return;
        const oldEl = form.querySelector("#cpOld");
        const n1El = form.querySelector("#cpNew1");
        const n2El = form.querySelector("#cpNew2");
        const feedback = form.querySelector("#cpFeedback");
        const cancelBtn = form.querySelector("#cpCancel");
        const submitBtn = form.querySelector("#cpSubmit");
        function setFeedback(msg, ok = true) {
          if (feedback) {
            feedback.style.color = ok ? "#9cf0b7" : "#ff6b6b";
            feedback.textContent = msg;
          }
        }
        cancelBtn.onclick = () => {
          settingsModalMount.style.display = "none";
          settingsModalMount.innerHTML = "";
        };
        form.addEventListener("submit", async (e) => {
          e.preventDefault();
          if (!oldEl.value) {
            setFeedback("Current password required", false);
            return;
          }
          if (!n1El.value || !n2El.value) {
            setFeedback("New password fields required", false);
            return;
          }
          if (n1El.value !== n2El.value) {
            setFeedback("New passwords do not match", false);
            return;
          }
          if (n1El.value.length < 1) {
            setFeedback("Password too short", false);
            return;
          }
          setFeedback("Changing...", true);
          submitBtn.disabled = true;
          const orig = submitBtn.textContent;
          submitBtn.textContent = "Working...";
          try {
            const res = await fetch(`${apiBase}/change-password`, {
              method: "POST",
              headers: headers(),
              body: JSON.stringify({
                old_password: oldEl.value,
                new_password: n1El.value,
              }),
            });
            let data = {};
            try {
              data = await res.json();
            } catch (_) {}
            if (!res.ok) throw new Error(data.detail || res.statusText);
            setFeedback("Password changed successfully");
            showToast("Password changed");
            setTimeout(() => {
              settingsModalMount.style.display = "none";
              settingsModalMount.innerHTML = "";
            }, 1200);
          } catch (err) {
            setFeedback(err.message || "Change failed", false);
            showToast(err.message || "Change failed", false);
          } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = orig;
          }
        });
      }
      if (btnOpenSettings)
        btnOpenSettings.addEventListener("click", () =>
          openSettingsModal("password")
        );
      function buildInterfaceSuccessModal(kind, iface, port) {
        const heading =
          kind === "edited"
            ? "Interface edited successfully!"
            : kind === "activated"
            ? "Interface activated successfully!"
            : "Interface created successfully!";
        const p = port || "<port>";
        const i = iface || "<iface>";
        const fwCmd1 = `ufw allow ${p}/udp`;
        const fwCmd2 = `ufw route allow in on ${i} out on ${i}`;
        const gwName =
          typeof window !== "undefined" && window.PYGUARD_GATEWAY_NAME
            ? window.PYGUARD_GATEWAY_NAME
            : "<gateway>";
        const fwCmdGW1 = `ufw route allow in on ${i} out on ${gwName}`;
        const fwCmdGW2 = `ufw route allow in on ${gwName} out on ${i}`;
        const id1 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`;
        const id2 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`;
        const id3 = `pgc_${Date.now()}_${Math.random()
          .toString(36)
          .slice(2, 7)}`; // sysctl block
        const inDocker =
          typeof window !== "undefined" && window.PYGUARD_IN_DOCKER === 1;
        let bodyContent = "";
        if (inDocker) {
          // Docker mode: concise version without gateway note
          bodyContent = `\n    <div style=\"font-size:13px;color:#cfd8dc;display:flex;flex-direction:column;gap:14px;line-height:1.45;\">\n      <div>Interface <b>${i}</b> on port <b>${p}</b> is ready inside the container. Key steps:</div>\n      <ol style=\"margin:0 0 0 18px;padding:0;display:flex;flex-direction:column;gap:14px;\">\n        <li><b>Expose UDP port:</b><div style=\"margin-top:6px;\">Ensure container mapping host:${p} → container:${p} (compose snippet below). Upstream router / cloud SG must also allow/forward UDP <b>${p}</b>.</div><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"docker_compose_${id1}\">Copy</button><code id=\"docker_compose_${id1}\">ports:\n  - \"6656:6656/tcp\"\n  - \"${p}:${p}/udp\"</code></div></li>\n        <li><b>Edge & firewall allows:</b><div style=\"margin-top:6px;\">Public IP (or port‑forward) + cloud security group / router + host firewall must all permit inbound UDP <b>${p}</b>. Missing any layer breaks connectivity.</div></li>\n      </ol>\n      <div style=\"font-size:11px;color:#78909c;\">Host firewall tools run outside the container; ensure <code>NET_ADMIN</code> & <code>/dev/net/tun</code> are configured in compose/run args.</div>\n    </div>`;
        } else {
          // Normal (non-docker) mode: show UFW + sysctl guidance; optionally gateway NAT rules
          const allowGW = !!(
            currentServer &&
            (currentServer.allow_vpn_gateway ||
              currentServer["allow_vpn_gateway"])
          );
          const id4 = `pgc_${Date.now()}_${Math.random()
            .toString(36)
            .slice(2, 7)}`;
          const id5 = `pgc_${Date.now()}_${Math.random()
            .toString(36)
            .slice(2, 7)}`;
          const gwExtra = allowGW
            ? `\n        <li><b>Allow VPN gateway egress (peer → Internet) routing:</b><div style=\"margin-top:6px;\">When 'Allow VPN gateway' is enabled peers sending 0.0.0.0/0 (or broader) through the tunnel need host firewall forward allowances between the WireGuard interface <code>${i}</code> and the upstream gateway <code>${gwName}</code>:</div><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"${id4}\">Copy</button><code id=\"${id4}\">${fwCmdGW1}</code></div><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"${id5}\">Copy</button><code id=\"${id5}\">${fwCmdGW2}</code></div><div style=\"margin-top:6px;font-size:11px;color:#90a4ae;\">These ensure forwarded packets can traverse from VPN peers out to the Internet and return. Replace <code>${gwName}</code> if your default gateway device differs.</div></li>`
            : "";
          bodyContent = `\n    <div style=\"font-size:13px;color:#cfd8dc;display:flex;flex-direction:column;gap:14px;line-height:1.45;\">\n      <div>Interface <b>${i}</b> on port <b>${p}</b> is ready. To ensure full connectivity and proper WireGuard operation, review the recommended system steps below.</div>\n      <ol style=\"margin:0 0 0 18px;padding:0;display:flex;flex-direction:column;gap:14px;\">\n        <li><b>Expose and authorize the WireGuard UDP port; then allow intra-peer routing:</b><div style=\"margin-top:6px;\">First open the UDP port locally (host firewall) and permit routed traffic between peers on the interface:</div><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"${id1}\">Copy</button><code id=\"${id1}\">${fwCmd1}</code></div><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"${id2}\">Copy</button><code id=\"${id2}\">${fwCmd2}</code></div><div style=\"margin-top:6px;font-size:11px;color:#90a4ae;\">For peer-to-peer connectivity across the Internet the relay host must have a publicly reachable IP <i>or</i> a stable router/NAT port‑forward mapping UDP <b>${p}</b> to this machine. Without that only LAN / privately routed peers can connect. Also adjust cloud security groups / upstream firewalls accordingly.</div></li>\n        <li><b>Enable packet forwarding (kernel):</b><div class=\"pg-code-block pg-copy-wrap\"><button class=\"pg-copy-btn\" data-target=\"${id3}\">Copy</button><code id=\"${id3}\">sysctl -w net.ipv4.ip_forward=1\n# (optional IPv6)\nsysctl -w net.ipv6.conf.all.forwarding=1</code></div><span style=\"display:block;margin-top:4px;\">Persist via /etc/sysctl.conf if desired.</span></li>${gwExtra}\n      </ol>\n    </div>`;
        }
        return `\n<div class=\"peer-modal-overlay\">\n  <div class=\"peer-modal\" style=\"max-width:640px;\" role=\"dialog\" aria-modal=\"true\">\n    <button class=\"peer-modal-close\" id=\"ismClose\" aria-label=\"Close\">×</button>\n    <h3 style=\"margin-top:0;\">${heading}</h3>${bodyContent}\n    <div class=\"pm-actions\" style=\"margin-top:18px;justify-content:flex-end;gap:10px;\">\n      ${
          inDocker
            ? ""
            : '<button type="button" id="ismApplyRules" class="btn-glow pg-fixed-btn" style="background:#1f3a4d;">Apply Rules</button>'
        }\n      <button type=\"button\" id=\"ismUnderstand\" class=\"btn-glow\">I Understand</button>\n    </div>\n  </div>\n</div>`;
      }
      function showInterfaceSuccess(kind, iface, port) {
        if (!interfaceSuccessMount) return;
        interfaceSuccessMount.innerHTML = buildInterfaceSuccessModal(
          kind,
          iface,
          port
        );
        interfaceSuccessMount.style.display = "block";
        const overlay = interfaceSuccessMount.querySelector(
          ".peer-modal-overlay"
        );
        const btnClose = interfaceSuccessMount.querySelector("#ismClose");
        const btnOk = interfaceSuccessMount.querySelector("#ismUnderstand");
        const btnApply = interfaceSuccessMount.querySelector("#ismApplyRules");
        if (btnApply) {
          const applyIface = iface;
          const applyPort = port;
          btnApply.addEventListener("click", async () => {
            if (!applyPort || !applyIface) {
              showToast("Missing interface or port", false);
              return;
            }
            if (btnApply.getAttribute("data-busy") === "1") return;
            const orig = btnApply.textContent;
            btnApply.setAttribute("data-busy", "1");
            btnApply.textContent = "Applying...";
            btnApply.disabled = true;
            try {
              await fetchJSON(
                `${apiBase}/shell/port/${encodeURIComponent(applyPort)}`,
                { method: "POST", headers: headers() }
              );
              await fetchJSON(
                `${apiBase}/shell/route/${encodeURIComponent(applyIface)}`,
                { method: "POST", headers: headers() }
              );
              try {
                if (
                  currentServer &&
                  (currentServer.allow_vpn_gateway ||
                    currentServer["allow_vpn_gateway"])
                ) {
                  await fetchJSON(
                    `${apiBase}/shell/route_vpn_gateway/${encodeURIComponent(
                      applyIface
                    )}`,
                    { method: "POST", headers: headers() }
                  );
                }
              } catch (_e) {
                /* non-fatal */
              }
              btnApply.textContent = "Applied";
              showToast("Rules applied");
              setTimeout(() => {
                btnApply.textContent = orig;
                btnApply.disabled = false;
                btnApply.removeAttribute("data-busy");
              }, 2200);
            } catch (e) {
              btnApply.textContent = "Failed";
              showToast(e.message || "Apply failed", false);
              setTimeout(() => {
                btnApply.textContent = orig;
                btnApply.disabled = false;
                btnApply.removeAttribute("data-busy");
              }, 2500);
            }
          });
        }
        // Copy button handler (event delegation for this modal instance)
        interfaceSuccessMount
          .querySelectorAll(".pg-copy-btn")
          .forEach((btn) => {
            btn.addEventListener("click", (e) => {
              e.stopPropagation();
              const targetId = btn.getAttribute("data-target");
              const codeEl = targetId
                ? interfaceSuccessMount.querySelector(
                    `#${CSS.escape(targetId)}`
                  )
                : null;
              const text = codeEl ? codeEl.innerText : "";
              if (!text) return;
              const copyText = async (t) => {
                try {
                  if (navigator.clipboard && window.isSecureContext) {
                    await navigator.clipboard.writeText(t);
                  } else {
                    const ta = document.createElement("textarea");
                    ta.value = t;
                    ta.style.position = "fixed";
                    ta.style.top = "-2000px";
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand("copy");
                    ta.remove();
                  }
                  btn.classList.add("copied");
                  const original = btn.textContent;
                  btn.textContent = "Copied";
                  setTimeout(() => {
                    btn.textContent = original;
                    btn.classList.remove("copied");
                  }, 1500);
                } catch (_) {
                  const original = btn.textContent;
                  btn.textContent = "Failed";
                  setTimeout(() => {
                    btn.textContent = original;
                  }, 1500);
                }
              };
              copyText(text);
            });
          });
        function close() {
          interfaceSuccessMount.style.display = "none";
          interfaceSuccessMount.innerHTML = "";
        }
        btnClose.onclick = close;
        btnOk.onclick = close;
        overlay.addEventListener("click", (e) => {
          if (e.target === overlay) close();
        });
      }
    </script>
  </body>
</html>
